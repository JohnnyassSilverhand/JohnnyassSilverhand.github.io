<center><font face="华文中宋" size=6><b>中山大学计算机学院</b></font></center>

<center><font face="华文中宋" size=6><b>人工智能</b></font></center>

<center><font face="华文中宋" size=6><b>本科生实验报告</b></font></center>

<center><font face="华文中宋" size=4><b>(2022春季学期)</b></font></center>

课程名称：Artificial Intelligence

| 教学班级  |   专业（方向）   |   学号   |  姓名  |
| :-------: | :--------------: | :------: | :----: |
| 20计科1班 | 计算机科学与技术 | 20337035 | 何雨桐 |

## 一、实验题目

使用模拟退火和遗传算法，解决TSP问题。

TSP问题即旅行商问题，经典的TSP可以描述为：一个商品推销员要去若干个城市推销商品，该推销员从一个城市出发，需要经过所有城市后，回到出发地。应如何选择行进路线，以使总的行程最短。

- 模拟退火：
  1. 采用多种邻域操作的局部搜索local search策略求解；
  2. 在局部搜索策略的基础上，加入模拟退火simulated annealing策略，并比较两者的效果；
  3. 要求求得的解不要超过最优值的10％，并能够提供可视化，观察路径的变化和交叉程度。
- 遗传算法：
  1. 设计较好的交叉操作，并且引入多种局部搜索操作（可替换通常遗传算法的变异操作）
  2. 和之前的模拟退火算法（采用相同的局部搜索操作）进行比较
  3. 得出设计高效遗传算法的一些经验，并比较单点搜索和多点搜索的优缺点。

## 二、实验内容

### 1. 算法原理

模拟退火算法与遗传算法皆为在局部搜索基础上的优化算法。局部搜索（Local Search）是指寻找近似最优解、不断优化局部最优解的启发式算法。其基本思路为，算法从一个或若干个初始解出发，在当前状态的邻域中搜索出若干个候选解，并以某种策略在候选解中确定新的当前解；重复执行上述搜索过程，直至满足算法终止条件，结束搜索过程并输出近似最优结果。

#### 1、获取新邻域的算子设计

无论是变邻域算法与模拟退火算法的扰动操作、变邻域操作，还是遗传算法的变异操作，本质上都是产生新邻域的随机解，都可采用以下算子。

##### 1）将路径四个区间随机排序

```python
#扰动产生新的随机解，扰动方式为分成四个区间随机排序
def shaking(path):
    global size
    ini = visited[path]
    cnt = 0
    while True:
        pos1,pos2,pos3 = sorted(random.sample(range(0,size),3))
        path_ = path[pos1:pos2] + path[:pos1] + path[pos3:] + path[pos2:pos3]
        if path_ not in visited:
            cost = getCost(path_)
            visited.update({path_:cost})
        else:
            cost = visited[path_]
        cnt+=1
        if ini >= cost:
            break
        elif cnt > 100:
            path_ = path
            cost = ini
            break
    return path_
```

##### 2）反转一段区间

```python
#反转一段区间，获取新邻域
def getNei_rev(path):
    global size
    min = visited[path]
    cnt = 0
    while True:
        i,j = sorted(random.sample(range(1,size-1),2))
        path_ = path[:i] + path[i:j+1][::-1] + path[j+1:]
        if path_ not in visited:
            cost = getCost(path_)
            visited.update({path_:cost})
        else:
            cost = visited[path_]
        cnt+=1
        if cost < min:
            min = cost
            break
        elif cnt > 1000:
            path_ = path
            break
    return path_,min
```

##### 3）交换两个城市

```python
#交换两个城市，获取新邻域
def getNei_exc(path):
    global size
    min = visited[path]
    cnt = 0
    while True:
        i,j = sorted(random.sample(range(1,size-1),2))
        path_ = path[:i] + path[j:j+1] + path[i+1:j] + path[i:i+1] + path[j+1:]
        if path_ not in visited:
            cost = getCost(path_)
            visited.update({path_:cost})
        else:
            cost = visited[path_]
        cnt+=1
        if cost < min:
            min = cost
            break
        elif cnt > 1000:
            path_ = path
            break
    return path_,min
```

##### 4）随机挑选两个城市插入序列头部

```python
#随机挑选两个城市插入序列头部，获取新邻域
def getNei_ins(path):
    global size
    min = visited[path]
    cnt = 0
    while True:
        i,j = sorted(random.sample(range(1,size-1),2))
        path_ = path[i:i+1] + path[j:j+1] + path[:i] + path[i+1:j] + path[j+1:]
        if path_ not in visited:
            cost = getCost(path_)
            visited.update({path_:cost})
        else:
            cost = visited[path_]
        cnt+=1
        if cost < min:
            min = cost
            break
        elif cnt > 1000:
            path_ = path
            break
    return path_,min
```



#### 2、变邻域搜索算法（VNS）

变邻域搜索算法（Variable Neighborhood Search）是一种改进的局部搜索算法。此处的邻域，是指当前状态的临近状态，通过扰动、变邻域等函数操作，在邻域中产生新的随机解，选择其中的局部优解替代当前解，反复迭代，以此逼近最优解。

VNS的算法思路为：

1. 初始化，选择一个可行的初始解；
2. 扰动当前解，获得一个新的解；
3. 使用变邻域（Variable Neighborhood Descent, VND）策略的局部搜索：
   1. 用当前解作为初始解
   2. 对当前解做变邻域操作，假如得到的解比当前解更优，将变邻域后得到的解作为下一次迭代的当前解
   3. 重复第二步，直到迭代次数满足终止条件，返回局部最优解，退出迭代
4. 假如在VND操作中获得的局部最优解较当前解更优，则令其替代当前解，将迭代计数置为0；反之，迭代计数加一。
5. 返回第二步，重复直到迭代次数满足终止条件，返回近似最优解，退出迭代。

其伪代码为：

VNS：

![image-20220411231616652](https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202204112316761.png)

VND策略：

![image-20220411231625863](https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202204112316915.png)

#### 3、模拟退火（SA）

基于上述的变邻域搜索算法，加入模拟退火策略，即为模拟退火算法。

模拟退火算法的原理类似固体的物理退火过程，在进行随机生成解的过程中，接受劣解的概率逐渐下降趋近0，由随机搜索（高温）转变为局部搜索（降温），最终算法找到最优解（达到物理基态）。

模拟退火算法的本质是通过温度来控制算法接受劣解的概率。

退火系数在0.99，$$\frac{1}{lg(k+1)}$$（经典退火），$$\frac{1}{k+1}$$（快速退火）三者之间选择，其中最后一个系数搜索效率较快。

接受劣解的概率公式为：$$e^{\frac{f(x)-f(x')}{tk}}$$

SA的算法思路为：

1. 初始化，选择一个可行的初始解，以路径总长度为适应值，长度越短，解越优，越适应环境；
2. 在当前解的邻域中随机选择一个解，若该解优于当前解，替换该解为当前解；反之，计算接受概率，若产生的介于（0，1）之间的随即小数小于该概率，则接受该劣解，否则以当前解继续下一次迭代。
3. 重复第二步，直到搜索在当前温度下达到收敛，进行降温冷却操作，返回第二步；
4. 重复二、三步直到温度降温至满足终止条件，返回近似最优解，退出迭代。

其伪代码为：

![SA伪代码](https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202204120001522.png)

#### 4、遗传算法（GA）

遗传算法的基本原理是通过作用于染色体上的基因寻找好的染色体来求解问题，它需要对算法所产生的每个染色体进行评价，并基于适应度值来选择染色体，使适应性好的染色体有更多的繁殖机会，在遗传算法中，通过随机方式产生若干个所求解问题的数字编码，即染色体，形成初始种群；通过适应度函数给每个个体一个数值评价，淘汰低适应度的个体，选择高适应度的个体参加遗传操作，经过遗传操作后的个体集合形成下一代新的种群，对这个新的种群进行下一轮的进化。

遗传算法主要分为四个部分：交叉（crossover）、变异（mutation）、评估（fitness）、选择（selection）。

交叉算子有：部分映射（Partial-Mapped Crossover）、顺序交叉（OX crossover）、基于位置的交叉（Position-based Crossover ）、基于顺序的交叉（Order-Based Crossover ）、循环交叉（Cycle Crossover）。在本实验中采取部分映射法（PMX）。

变异算子有：反转变异（Invertion）、插入变异（Insertion）、替代变异（displacement）、交换变异（swap）、启发式变异（heuristic）。在本实验中测试反转变异与交换变异，结果表明反转变异的效率要优于交换变异。

GA的算法思路为：

1. 初始化，选择一个可行的初始解种群，对该种群的适应度进行评估；
2. 对当前解种群进行交叉、变异、评估操作；
3. 在当前解与经过交叉变异得到的子种群中，根据适应度评估值进行选择，得到下一代种群，重复第二步；
4. 重复二、三步直到迭代次数满足终止条件，返回近似最优解，退出迭代。

其伪代码为：

![image-20220412002933001](https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202204120029102.png)

### 2. 关键代码展示

#### 1、读取输入，存储地图

读取城市的横纵坐标后，求出两两间的二维欧几里得距离，用一个全局变量`DIST`二维数组进行记录，使计算路径长度时无需反复计算两城市间的二维欧几里得距离。

```python
#读取城市的x，y坐标
def load(txt):
    f = open(txt)
    map=[]
    flag = 0
    for line in f:
        line = line.strip()
        if line == "NODE_COORD_SECTION":
            flag = 1
            continue
        if line == "EOF":
            break
        if flag:
            a = line.split()
            map.append((float(a[1]),float(a[2])))
    return tuple(map)

#获取两个城市间的二维欧几里得距离
def getDist():
    global map,size
    dist = np.zeros((size,size))
    for i in range(0,size):
        for j in range(0,size):
            dist[i][j] = ((map[i][0]-map[j][0])**2 + (map[i][1]-map[j][1])**2)**0.5
    return dist
```

#### 2、计算路径长度

```python
#根据路径获取该路径总代价
def getCost(path):
    cost = 0
    former = path[0]
    for city in path:
        cost += DIST[former][city]
        former = city
    cost += DIST[path[0]][path[-1]]
    return cost
```

#### 3、VND

在局部搜索中使用VND策略进行搜索。

```python
#在Local Search中使用VND方法进行搜索        
def VND(path):
    l = 0
    min = visited[path]
    while l < 3:
        if l == 0:
            path_,cost = getNei_rev(path)
        elif l == 1:
            path_,cost = getNei_exc(path)
        elif l == 2:
            path_,cost = getNei_ins(path)
        if cost < min:
            path = path_
            min = cost
            l = 0
        else:
            l+=1
    return path,min 
```

#### 4、VNS

```python
#进行变邻域局部搜素
def VNS(path,kmax):
    k = 0
    temp = path
    min = solutions[0]
    global count
    while k < kmax:
        #扰动后进行变邻域操作
        path_nei,cost = VND(shaking(temp))
        print(cost)
        solutions.append(cost)
        count+=1
        if cost < min:
            temp = path_nei #记录迭代过的最优的解
            min = cost
            k = 0
        else:
            k+=1
    return temp,min
```

#### 5、SA

```python
#模拟退火算法
def SA(path,kmax,t0,t_end):
    temp = path
    min = solutions[0] 
    result = [temp,min] #记录迭代过的最优的解
    global count
    t = t0 #初始温度
    while t > t_end:
        for k in range(1,kmax):
            path_nei,cost = VND(temp) #进行变邻域操作
            #print(cost)
            solutions.append(cost)
            count+=1
            #判断是否接受该解
            if cost < min or random.random() < np.exp(-((cost-min)/t*k)):
                temp = path_nei
                min = cost
            if cost < result[1]:
                result = [path_nei,cost]
        #t/=math.log10(1+k)
        t/=k+1 #降温操作
    return result[0],result[1]
```

#### 6、PMX

```python
#Partial-Mapped crossover
def PMX(i,j):
    global size
    s,t = sorted(random.sample(range(1,size),2))
    next_i = list(i[:s] + j[s:t] + i[t:])
    next_j = list(j[:s] + i[s:t] + j[t:])
    #建立映射表
    mapped_i = {next_i[k]:next_j[k] for k in range(s,t)}
    mapped_j = {next_j[k]:next_i[k] for k in range(s,t)}
    #判断是否满足解的条件（每个城市皆访问一次）
    while len(set(next_i)) != len(next_i): 
        for k in range(size):
            if k < t and k >= s:
                continue
            while next_i[k] in j[s:t]:
                next_i[k] = mapped_i[next_i[k]]
    while len(set(next_j)) != len(next_j):
        for k in range(size):
            if k < t and k >= s:
                continue
            while next_j[k] in i[s:t]:
                next_j[k] = mapped_j[next_j[k]]
    next_i = tuple(next_i)
    next_j = tuple(next_j)
    if next_i not in visited:
        visited.update({next_i:getCost(next_i)})
    if next_j not in visited:
        visited.update({next_j:getCost(next_j)})
    return next_i,next_j
```

#### 7、GA

```python
#遗传算法
def GA(paths,kmax):
    global M,solutions
    temp = paths
    for k in range(kmax):
        count = 0
        flag = 0
        children = [] #存储此代交叉、变异产生的子种群
        #加入当前种群中的最优解，使得下一代种群的最优解一定不会劣于当前种群最优解
        children.append(temp[0]) 
        for l in range(M):
            while True:
                i,j = random.sample(range(M),2)
                count+=1
                if temp[i] != temp[j]:
                    break
                if count > 1000000:
                    flag = 1
                    break
            if flag == 0:
                a,b = PMX(temp[i],temp[j]) #使用PMX交叉操作
                children.append(a)
                children.append(b)
        for l in range(M):
            i = random.randrange(M)
            children.append(reverse(temp[i])) #使用反转一段区间作为变异操作
        temp = sorted(children[:], key=lambda x:visited[x])[:M] #选取子代中最优的前M个解
        solutions.append(visited[temp[0]]) #记录此次迭代产生的下一代的最优解
        print(k,visited[temp[0]])
    return temp[0]
```



### 3. 创新点与优化

#### 1、缩短迭代中计算距离的时间

1）用一个全局变量`DIST`二维数组记录所有城市两两间的距离，使计算路径长度时无需反复计算两城市间的二维欧几里得距离。

2）用一个全局变量`visited`字典记录已经搜索过的路径，以元组储存路径作为键值，储存其路径长度。在搜索过程中，可能多次搜索到同一条路径，可以在`visited`字典中直接获取路径，无需反复计算。

#### 2、控制搜索方向向最优化迭代

1）在扰动、变邻域、变异操作中，通过反复随机生成路径，选择候选解中优于当前解的路径；若多次随机后当前路径仍然为最优，则返回此次已搜索路径中的最优解。通过控制最大随机生成路径的次数，可以有效控制搜索方向向最优化迭代，效率提高。

2）在遗传算法中，每一次迭代，将当代种群的最优路径复制到子代种群，在经过交叉、变异操作后，使用精英（elitist）策略，再在子代种群中选择最优的前M（种群大小）个解，以此保证下一代种群的最优解一定不会劣于当前种群最优解，搜索方向向最优化迭代。

## 三、实验结果及分析

### 1. VNS

#### ch130：

**参数设置**：

最大扰动次数（多次随机以提高获得更优解的概率）为10，每次变邻域操作的最大重复次数为100，对单一当前解的最大迭代次数（kmax）为1000

**输出结果**：

```
Algorithm VNS iterated 1374 times!

You got the best solution:
6678.767498887646
(2, 113, 125, 7, 107, 17, 45, 79, 49, 70, 129, 1, 117, 19, 20, 32, 22, 39, 46, 21, 36, 92, 43, 54, 121, 95, 12, 66, 13, 9, 101, 5, 90, 71, 48, 91, 72, 98, 73, 74, 51, 8, 56, 55, 64, 80, 102, 81, 100, 122, 110, 118, 83, 35, 31, 112, 24, 47, 97, 109, 88, 93, 76, 28, 14, 18, 26, 99, 115, 23, 94, 78, 86, 11, 37, 105, 57, 52, 119, 59, 50, 41, 3, 34, 53, 16, 30, 33, 42, 103, 126, 106, 67, 62, 69, 96, 6, 25, 87, 85, 68, 63, 123, 128, 60, 108, 75, 10, 4, 44, 15, 0, 40, 38, 116, 111, 127, 104, 61, 114, 27, 65, 84, 124, 89, 58, 77, 120, 29, 82, 2)
The best solution should be: 6110
误差为： 0.09308797035804355
```

**路径图像（左）与最优解收敛曲线（右）**：

![VNS3.0_CH130](https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202204030114714.png)

#### ch150：

**参数设置**：

最大扰动次数（shaking cnt）为100，每次变邻域操作的最大重复次数为1000，对单一当前解的最大迭代次数（kmax）为1000

**输出结果**：

```
Algorithm VNS iterated 1197 times!

You got the best solution:
7106.112914012118
(55, 89, 45, 91, 53, 137, 133, 132, 14, 77, 15, 58, 78, 120, 93, 87, 20, 63, 111, 135, 73, 12, 105, 90, 118, 67, 127, 103, 3, 44, 70, 43, 114, 149, 124, 21, 148, 61, 2, 112, 9, 47, 72, 75, 86, 0, 33, 62, 95, 88, 7, 29, 83, 6, 97, 102, 81, 94, 106, 4, 99, 142, 96, 123, 34, 92, 51, 110, 104, 32, 125, 145, 25, 74, 17, 141, 84, 64, 54, 57, 85, 107, 69, 134, 49, 131, 136, 101, 113, 98, 18, 1, 28, 80, 109, 46, 36, 5, 27, 8, 41, 119, 138, 39, 52, 11, 23, 117, 126, 68, 35, 60, 10, 147, 129, 16, 65, 59, 139, 116, 26, 122, 30, 128, 40, 56, 38, 100, 115, 37, 22, 143, 48, 146, 144, 71, 79, 13, 121, 76, 130, 31, 66, 42, 108, 50, 19, 24, 140, 82, 55)
The best solution should be: 6528
误差为： 0.08855896354352304
```

![VNS3.0_CH150](https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202204030121809.png)

#### a280：

**参数设置**：

最大扰动次数（shaking cnt）为100，每次变邻域操作的最大重复次数为1000，对单一当前解的最大迭代次数（kmax）为1000

**输出结果**：

```
Algorithm VNS iterated 1039 times!

You got the best solution:
2769.8125693197653
(0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 23, 22, 24, 21, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 121, 120, 119, 118, 156, 157, 158, 159, 174, 173, 172, 171, 170, 169, 168, 167, 166, 165, 164, 163, 162, 161, 160, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 155, 152, 154, 153, 122, 123, 124, 125, 126, 127, 128, 129, 130, 20, 19, 18, 131, 132, 133, 134, 135, 136, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 2, 1, 279, 0)     
The best solution should be: 2579
误差为： 0.07398703734771823
```

![VNS3.0_A280](https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202204030125919.png)

### 2. SA

#### ch130：

##### 1）优化前

**参数设置**：

退火系数q = 0.99

单温度下最大迭代次数kmax = 100

初始温度t0 = 500000

终止温度t_end = 0.00001

不设置获取更优随机解的收敛次数条件。

**输出结果**：

```
Algorithm SA iterated 242748 times!

It cost 82.23166942596436s
You got the best solution:
6585.807272269674
(49, 1, 117, 79, 45, 19, 92, 36, 21, 46, 39, 22, 121, 95, 12, 66, 13, 9, 101, 5, 90, 71, 91, 72, 98, 73, 74, 51, 8, 56, 81, 100, 122, 110, 118, 83, 35, 76, 102, 55, 64, 11, 86, 80, 93, 88, 28, 14, 23, 115, 94, 78, 37, 105, 57, 48, 52, 119, 59, 50, 54, 43, 41, 3, 34, 53, 16, 33, 30, 99, 26, 18, 42, 103, 126, 106, 109, 97, 112, 31, 24, 47, 67, 62, 69, 96, 6, 25, 87, 85, 68, 63, 123, 128, 60, 108, 75, 10, 4, 44, 15, 127, 104, 111, 61, 114, 27, 65, 84, 124, 89, 58, 77, 120, 32, 20, 17, 107, 7, 125, 29, 113, 2, 82, 116, 38, 40, 0, 70, 129, 49)
The best solution should be: 6110
误差为： 0.07787353064970119
```

![SA0.99_CH130](https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202204070027454.png)

##### 2）优化后

**参数设置**：

改变退火系数，改为使用快速退火的系数（$$\frac{1}{k+1}$$），设置获取更优随机解的收敛次数条件。

退火系数q = $$\frac{1}{k+1}$$

单温度下最大迭代次数kmax = 100

初始温度t0 = 500000

终止温度t_end = 0.00001

获取更优随机解的收敛次数条件cnt = 100

**输出结果**：

```
Algorithm SA iterated 594 times!

It cost 9.481016397476196s
You got the best solution:
6468.925128883326
(70, 38, 40, 0, 126, 106, 103, 42, 33, 16, 53, 30, 99, 26, 18, 14, 28, 23, 115, 94, 78, 11, 86, 80, 76, 102, 64, 55, 51, 8, 56, 81, 100, 122, 110, 118, 83, 35, 31, 112, 93, 88, 109, 97, 24, 47, 67, 62, 69, 96, 6, 25, 87, 85, 68, 63, 123, 128, 60, 108, 10, 4, 75, 44, 15, 127, 116, 111, 104, 61, 27, 114, 82, 2, 29, 58, 89, 124, 84, 65, 77, 120, 125, 113, 107, 7, 17, 20, 32, 21, 36, 39, 46, 22, 54, 121, 95, 12, 66, 13, 9, 101, 5, 59, 50, 119, 57, 48, 71, 90, 98, 73, 74, 72, 91, 37, 105, 52, 41, 43, 92, 3, 34, 19, 45, 79, 117, 1, 49, 129, 70)
The best solution should be: 6110
误差为： 0.05874388361429225
```

![SA2.0_CH130](https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202204122327745.png)

多次运行得到以下结果：

|        | 1       | 2       | 3       | 4       | 5       | 6       | 7       | 8       | 9       | 10      |
| ------ | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- |
| 时间   | 9.48s   | 8.93s   | 9.36s   | 8.86s   | 8.99s   | 8.76s   | 8.32s   | 8.88s   | 9.02s   | 9.01s   |
| 最优解 | 6468.92 | 6462.58 | 6451.92 | 6518.62 | 6553.85 | 6493.22 | 6292.94 | 6652.57 | 6466.69 | 6386.16 |
| 误差   | 5.87%   | 5.77%   | 5.60%   | 6.69%   | 7.26%   | 6.27%   | 2.30%   | 8.89%   | 5.84%   | 4.52%   |

由表格可见，运行时长平均为8.961s，得到的近似最优解平均为6474.75，平均误差为5.97%。

#### ch150：

**参数设置**：

改变退火系数，改为使用快速退火的系数（$$\frac{1}{k+1}$$），设置获取更优随机解的收敛次数条件。

退火系数q = $$\frac{1}{k+1}$$

单温度下最大迭代次数kmax = 100

初始温度t0 = 500000

终止温度t_end = 0.00001

获取更优随机解的收敛次数条件cnt = 100

**输出结果**：

```
Algorithm SA iterated 594 times!

It cost 10.053171634674072s
You got the best solution:
7117.528754929006
(43, 70, 44, 105, 12, 90, 118, 67, 127, 3, 103, 21, 124, 148, 61, 2, 112, 9, 47, 62, 29, 7, 83, 6, 33, 72, 75, 86, 0, 97, 102, 81, 94, 106, 4, 99, 142, 96, 145, 55, 25, 74, 17, 141, 84, 64, 54, 57, 49, 131, 136, 101, 113, 98, 107, 69, 134, 85, 28, 18, 1, 36, 5, 27, 8, 41, 119, 46, 109, 80, 19, 24, 140, 82, 89, 45, 137, 50, 138, 39, 52, 117, 23, 11, 115, 100, 40, 56, 38, 126, 68, 35, 60, 10, 147, 129, 16, 65, 59, 139, 116, 26, 30, 122, 73, 135, 111, 63, 144, 128, 143, 146, 48, 71, 13, 79, 77, 14, 132, 121, 76, 130, 22, 37, 31, 66, 42, 108, 133, 53, 91, 32, 125, 123, 88, 95, 34, 92, 51, 104, 110, 15, 58, 78, 120, 93, 87, 20, 114, 149, 43)
The best solution should be: 6528
误差为： 0.09030771368397764
```

![SA2.0_CH150](https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202204070029980.png)

多次运行得到以下结果：

|        | 1       | 2       | 3       | 4       | 5       | 6       | 7       | 8       | 9       | 10      |
| ------ | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- |
| 时间   | 10.05s  | 9.03s   | 9.61s   | 9.63s   | 10.92s  | 9.76s   | 9.84    | 10.53s  | 10.85s  | 10.87s  |
| 最优解 | 7117.53 | 7005.91 | 7170.14 | 7073.50 | 6976.40 | 6911.23 | 7144.70 | 6852.87 | 7088.04 | 7015.93 |
| 误差   | 9.03%   | 7.32%   | 7.06%   | 7.78%   | 6.87%   | 5.87%   | 9.45%   | 4.98%   | 8.69%   | 7.55%   |

由表格可见，运行时长平均为10.11s，得到的近似最优解平均为7035.625，平均误差为7.78%。

#### a280：

##### 1）优化前：

**参数设置**：

退火系数q = 0.99

单温度下最大迭代次数kmax = 100

初始温度t0 = 500000

终止温度t_end = 0.00001

不设置获取更优随机解的收敛次数条件。

**输出结果**：

```
Algorithm SA iterated 594 times!

It cost 17.579442262649536s
You got the best solution:
2818.621642239474
(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 0)
The best solution should be: 2579
误差为： 0.09291261816187442
```

![SA0.99_A280](https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202204122327592.png)

##### 2）优化后：

**参数设置**：

改变退火系数，改为使用快速退火的系数（$$\frac{1}{k+1}$$），设置获取更优随机解的收敛次数条件。由于初始解即与最优解误差在10%以内，并且该测例城市数较多，将kmax修改为1000，来遍历出更多可能结果。

退火系数q = $$\frac{1}{k+1}$$

单温度下最大迭代次数kmax = 1000

初始温度t0 = 500000

终止温度t_end = 0.00001

获取更优随机解的收敛次数条件cnt = 100

**输出结果**：

```
It cost 113.56555557250977s
You got the best solution:
2783.2709779606985
(0, 1, 241, 242, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 226, 227, 228, 229, 250, 230, 245, 244, 243, 246, 249, 248, 247, 278, 277, 258, 257, 256, 255, 254, 253, 252, 251, 208, 209, 210, 213, 214, 225, 224, 223, 222, 218, 221, 220, 219, 216, 217, 215, 212, 211, 206, 207, 205, 204, 203, 202, 201, 199, 198, 197, 200, 195, 194, 193, 196, 192, 191, 190, 189, 188, 187, 186, 185, 184, 183, 182, 181, 180, 179, 175, 176, 150, 151, 177, 178, 149, 148, 147, 146, 145, 144, 143, 142, 141, 140, 139, 265, 138, 137, 136, 266, 264, 263, 262, 261, 260, 259, 275, 274, 273, 272, 271, 270, 15, 16, 269, 268, 267, 135, 134, 133, 132, 131, 17, 18, 19, 130, 129, 20, 127, 128, 153, 154, 152, 155, 123, 122, 121, 120, 119, 118, 156, 157, 158, 159, 174, 160, 161, 162, 163, 164, 165, 166, 167, 99, 168, 169, 171, 170, 172, 173, 106, 105, 104, 107, 103, 102, 101, 100, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 108, 88, 80, 79, 78, 81, 75, 77, 76, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 63, 62, 64, 84, 85, 86, 83, 82, 87, 111, 109, 110, 113, 112, 115, 114, 116, 117, 61, 60, 59, 42, 58, 57, 56, 43, 44, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 124, 125, 126, 28, 27, 26, 25, 21, 24, 22, 23, 13, 14, 12, 11, 10, 9, 7, 8, 6, 5, 4, 276, 3, 2, 279, 0)
The best solution should be: 2579
误差为： 0.07920549746440422
```

![SA2.0_A280](https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202204070038498.png)

多次运行得到以下结果：

|        | 1       | 2       | 3       | 4       | 5       | 6       | 7       | 8       |
| ------ | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- |
| 时间   | 132.30s | 143.22s | 136.82s | 135.61s | 135.07s | 113.57s | 112.98s | 114.00s |
| 最优解 | 2730.15 | 2763.45 | 2799.30 | 2818.62 | 2768.67 | 2783.27 | 2782.90 | 2815.68 |
| 误差   | 5.86%   | 7.15%   | 8.54%   | 9.29%   | 7.35%   | 7.92%   | 7.91%   | 9.18%   |

由表格可见，运行时长平均为127.97s，得到的近似最优解平均为2782，平均误差为7.87%。

综上进行比较，优化后的模拟退火算法，相较优化前的模拟退火算法，时间大幅减少；相较基于变邻域策略的局部搜索，得到的近似最优解更精确，误差更小。

### 3. GA

#### ch130：

**参数设置**：

种群大小M = 30

交叉算子：部分映射PMX

变异算子：反转一段区间（通过测试，反转一段区间的效果要远优于交换两个城市）

选择算子：精英策略

交叉操作的收敛次数设为1000000，迭代1300次

**输出结果**：

```
It cost 653.6441254615784s
You got the best solution:
6453.500525770696
(48, 57, 71, 90, 98, 72, 91, 37, 105, 52, 119, 5, 101, 9, 13, 66, 12, 95, 121, 54, 59, 50, 41, 43, 92, 36, 21, 46, 39, 22, 32, 20, 125, 120, 77, 58, 29, 89, 124, 84, 65, 27, 114, 61, 104, 111, 116, 82, 2, 113, 107, 7, 17, 45, 79, 117, 19, 3, 34, 53, 1, 49, 129, 70, 38, 40, 0, 127, 15, 44, 4, 10, 75, 108, 60, 128, 123, 63, 68, 85, 87, 25, 6, 96, 69, 106, 126, 103, 33, 16, 30, 99, 26, 18, 42, 62, 67, 47, 24, 97, 109, 88, 28, 14, 23, 115, 94, 78, 11, 86, 80, 102, 76, 93, 112, 31, 35, 83, 118, 110, 122, 100, 81, 56, 8, 55, 64, 51, 74, 73, 48)
误差为： 0.05621939865314177
```

![GA1.0（换参数）_CH130](https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202204080020560.png)

**改变参数**：

种群大小M = 30

交叉算子：部分映射PMX，择当前种群最优解和其中一随机解进行交叉（保留优势基因）

变异算子：反转一段区间（通过测试，反转一段区间的效果要远优于交换两个城市）

选择算子：精英策略

交叉操作的收敛次数设为100000，迭代1300次

**输出结果**：

```
It cost 691.4561274051666s
You got the best solution:
6337.477311760854
(106, 126, 103, 42, 18, 26, 99, 30, 33, 16, 53, 1, 49, 129, 70, 38, 40, 0, 75, 60, 108, 10, 4, 44, 15, 127, 104, 61, 111, 116, 114, 27, 65, 84, 124, 89, 58, 29, 82, 2, 113, 107, 7, 17, 20, 32, 125, 120, 77, 12, 66, 95, 9, 13, 121, 54, 101, 5, 90, 71, 48, 57, 52, 119, 59, 50, 41, 43, 39, 46, 22, 21, 36, 92, 19, 45, 79, 117, 34, 3, 105, 37, 91, 72, 98, 73, 74, 51, 64, 55, 8, 56, 81, 100, 122, 110, 118, 83, 35, 31, 112, 93, 76, 102, 80, 86, 11, 78, 94, 115, 23, 14, 28, 88, 109, 97, 24, 47, 67, 62, 6, 87, 85, 68, 63, 123, 128, 25, 96, 69, 106)
误差为： 0.03723032925709555
```

![image-20220412232228940](https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202204122322053.png)

多次运行得到以下结果：

|        | 1       | 2       | 3       | 4       | 5       |
| ------ | ------- | ------- | ------- | ------- | ------- |
| 时间   | 691.46s | 682.58s | 661.64s | 711.55s | 686.22s |
| 最优解 | 6337.48 | 6466.19 | 6216.40 | 6333.75 | 6290.18 |
| 误差   | 3.72%   | 5.83%   | 1.74%   | 3.66%   | 2.95%   |

由表格可见，运行时长平均为686.69s，得到的近似最优解平均为6328.8，平均误差为3.58%。

#### ch150：

**参数设置**：

种群大小M = 30

交叉算子：部分映射PMX

变异算子：反转一段区间（通过测试，反转一段区间的效果要远优于交换两个城市）

选择算子：精英策略

交叉操作的收敛次数设为1000000，迭代1300次

**输出结果**：

```
Algorithm GA iterated 1300 times!

It cost 340.5782082080841s
You got the best solution:
6890.38065037357
(66, 42, 11, 115, 100, 38, 56, 40, 37, 22, 31, 130, 76, 121, 13, 79, 71, 48, 146, 143, 128, 26, 30, 144, 63, 111, 135, 122, 73, 12, 105, 90, 118, 67, 127, 44, 70, 43, 20, 149, 114, 3, 103, 21, 124, 148, 61, 2, 112, 9, 93, 87, 120, 78, 77, 14, 58, 15, 132, 110, 104, 32, 125, 51, 92, 123, 34, 95, 88, 7, 6, 83, 29, 62, 47, 72, 75, 33, 86, 0, 97, 102, 81, 94, 106, 4, 99, 142, 96, 145, 25, 55, 91, 53, 45, 137, 133, 108, 50, 19, 24, 89, 82, 74, 17, 141, 84, 64, 131, 136, 49, 54, 57, 140, 80, 109, 28, 85, 134, 69, 107, 101, 113, 98, 18, 1, 36, 5, 27, 8, 41, 119, 46, 138, 39, 52, 23, 117, 126, 68, 35, 60, 10, 147, 129, 16, 65, 59, 139, 116, 66)
误差为： 0.05551174178516691
```

![GA1.0_CH150](https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202204080038887.png)

#### a280：

**参数设置**：

种群大小M = 30

交叉算子：部分映射PMX

变异算子：反转一段区间（通过测试，反转一段区间的效果要远优于交换两个城市）

选择算子：精英策略

交叉操作的收敛次数设为1000000，迭代1300次

**输出结果**：

```
Algorithm GA iterated 1300 times!

It cost 169.19513702392578s
You got the best solution:
2764.948298260772
(248, 254, 251, 208, 207, 252, 253, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 139, 138, 148, 149, 137, 265, 266, 267, 136, 135, 134, 268, 269, 133, 132, 17, 16, 15, 270, 271, 272, 273, 274, 275, 276, 3, 278, 277, 247, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 230, 245, 244, 246, 249, 250, 229, 228, 227, 226, 225, 224, 223, 222, 218, 221, 220, 219, 216, 217, 214, 215, 213, 212, 211, 210, 209, 206, 205, 204, 203, 202, 201, 200, 199, 143, 142, 141, 140, 147, 146, 145, 144, 198, 197, 196, 195, 194, 193, 192, 191, 190, 189, 188, 187, 186, 185, 184, 183, 182, 181, 180, 179, 178, 175, 176, 177, 150, 151, 155, 152, 119, 118, 156, 157, 158, 159, 174, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 171, 170, 173, 172, 105, 104, 106, 109, 110, 113, 112, 111, 87, 86, 85, 83, 82, 81, 80, 88, 108, 107, 103, 89, 79, 90, 91, 102, 101, 100, 99, 98, 97, 92, 93, 96, 95, 94, 78, 77, 76, 74, 75, 73, 72, 71, 70, 69, 66, 65, 84, 64, 63, 68, 67, 57, 56, 43, 58, 62, 115, 114, 116, 117, 61, 60, 59, 42, 41, 40, 39, 46, 45, 44, 55, 54, 53, 47, 52, 51, 50, 49, 48, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 124, 123, 122, 121, 120, 154, 153, 128, 129, 130, 131, 18, 19, 20, 127, 126, 125, 28, 27, 26, 25, 21, 24, 22, 23, 13, 12, 14, 11, 10, 9, 7, 8, 6, 5, 4, 0, 1, 279, 2, 248)   
误差为： 0.0721009299188724
```

![GA1.0_A280](https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202204080038847.png)

由上述数据可以看出，要得到近似精确度的最优解，遗传算法的用时要远大于模拟退火算法，但其搜索到的最优解平均情况下比模拟退火算法得到的更优秀，误差更小。



综上所述，变邻域搜索算法、模拟退火算法、遗传算法皆能得到误差在10%以内的近似最优解。从时间消耗上看，三种算法的优秀程度为：模拟退火＞变邻域搜索＞遗传。从解的精确度看，三种算法的优秀程度为：遗传＞模拟退火＞变邻域搜索。综合二者考量，模拟退火的表现最为高效。

## 四、参考资料

[遗传算法一些交叉算子_Alvin Jiao的博客-CSDN博客_单点交叉](https://blog.csdn.net/u010743448/article/details/108445588)

[模拟退火算法+局部搜索算法求解TSP问题（C++实现）_Dic0k的博客-CSDN博客_tsp局部搜索](https://blog.csdn.net/dickdick111/article/details/85119471?ops_request_misc=%7B%22request%5Fid%22%3A%22164864971416782094890146%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=164864971416782094890146&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-85119471.142^v5^pc_search_insert_es_download,143^v6^control&utm_term=局部搜索+tsp&spm=1018.2226.3001.4187)

[干货 | 变邻域搜索算法(Variable Neighborhood Search,VNS)超详细一看就懂 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU0NzgyMjgwNg==&mid=2247484621&idx=1&sn=f2e92f44c2306b58034cf158647bc737&chksm=fb49c974cc3e406228737e1a986c73368131bc7f0c0251d82b1e64266220df59134ab0a9def1&mpshare=1&scene=1&srcid=0828EK2xkjxczX8dMch3ud66&sharer_sharetime=1566963711577&sharer_shareid=054592193644de509623829748e83807&key=d4d627468bf29e729a37d96e9420f75ae8ee07d92976b165df3762d4a0bf2e01a06e3591d4793592a5980676c1d1668f96fe3e822792af675cd35f1752c460bc5edec3bfc0549fe8ec7273a4243355f3&ascene=1&uin=MjYzMDA1MzAyMQ%3D%3D&devicetype=Windows+10&version=62060834&lang=zh_CN&pass_ticket=mKdxom8osJJZb4ixH2eELB08AKAMdUQR7xMY0nJhEcpBIeHmtdQToh3Nk47Aacno)

