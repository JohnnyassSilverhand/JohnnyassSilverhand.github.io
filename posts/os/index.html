<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="en"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="OS Outline" /><meta property="og:locale" content="en" /><meta name="description" content="OS期末复习 OS期末复习" /><meta property="og:description" content="OS期末复习 OS期末复习" /><link rel="canonical" href="https://witchpuff.github.io/posts/os/" /><meta property="og:url" content="https://witchpuff.github.io/posts/os/" /><meta property="og:site_name" content="CyberWitch" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-06-28T09:36:30+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="OS Outline" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-03-29T21:57:24+08:00","datePublished":"2022-06-28T09:36:30+08:00","description":"OS期末复习 OS期末复习","headline":"OS Outline","mainEntityOfPage":{"@type":"WebPage","@id":"https://witchpuff.github.io/posts/os/"},"url":"https://witchpuff.github.io/posts/os/"}</script><title>OS Outline | CyberWitch</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="CyberWitch"><meta name="application-name" content="CyberWitch"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img class="avatar" alt="WitchPuff" width="100" height="100" data-proofer-ignore="true" src="https://avatars2.githubusercontent.com/WitchPuff?v=3&s=100" srcset="https://avatars2.githubusercontent.com/WitchPuff?v=3&s=100 1x, https://avatars2.githubusercontent.com/WitchPuff?v=3&s=200 2x, https://avatars2.githubusercontent.com/WitchPuff?v=3&s=300 3x, https://avatars2.githubusercontent.com/WitchPuff?v=3&s=400 4x" /> </a></div><div class="site-title mt-3"> <a href="/">CyberWitch</a></div><div class="site-subtitle font-italic">A Room of One's Own</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/WitchPuff" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['ttqsjzsq','163.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>OS Outline</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>OS Outline</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1656380190" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jun 28, 2022 </em> </span> <span> Updated <em class="" data-ts="1680098244" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Mar 29, 2023 </em> </span><div class="d-flex justify-content-between"> <span> By <em> WitchPuff </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7359 words"> <em>40 min</em> read</span></div></div></div><div class="post-content"><ul id="markdown-toc"><li><a href="#os期末复习" id="markdown-toc-os期末复习">OS期末复习</a><ul><li><a href="#1-introduction" id="markdown-toc-1-introduction">1. Introduction</a><ul><li><a href="#os定义" id="markdown-toc-os定义">OS<strong>定义</strong></a><li><a href="#现代计算机硬件组成" id="markdown-toc-现代计算机硬件组成"><strong>现代计算机硬件组成</strong></a><ul><li><a href="#进程processor" id="markdown-toc-进程processor">进程（processor）</a><li><a href="#存储" id="markdown-toc-存储">存储</a><li><a href="#io" id="markdown-toc-io">IO</a></ul><li><a href="#中断" id="markdown-toc-中断">中断</a><ul><li><a href="#中断的分类" id="markdown-toc-中断的分类"><strong>中断的分类</strong></a></ul></ul><li><a href="#2-操作系统结构" id="markdown-toc-2-操作系统结构">2. 操作系统结构</a><ul><li><a href="#操作系统服务" id="markdown-toc-操作系统服务">操作系统服务</a><li><a href="#用户和程序员接口" id="markdown-toc-用户和程序员接口">用户和程序员接口</a><li><a href="#系统组件" id="markdown-toc-系统组件">系统组件</a><ul><li><a href="#简单结构" id="markdown-toc-简单结构">简单结构</a><li><a href="#微内核" id="markdown-toc-微内核">微内核</a><li><a href="#模块" id="markdown-toc-模块">模块</a></ul></ul><li><a href="#3-进程" id="markdown-toc-3-进程">3. 进程</a><ul><li><a href="#进程概念" id="markdown-toc-进程概念">进程概念</a><ul><li><a href="#进程" id="markdown-toc-进程">进程</a><li><a href="#状态" id="markdown-toc-状态">状态</a><li><a href="#进程表process-table" id="markdown-toc-进程表process-table"><strong>进程表（Process Table）</strong></a><li><a href="#进程控制块prosess-control-blockpcb" id="markdown-toc-进程控制块prosess-control-blockpcb">进程控制块（Prosess Control Block，PCB）</a></ul><li><a href="#进程调度process-scheduling" id="markdown-toc-进程调度process-scheduling">进程调度（Process Scheduling）</a><ul><li><a href="#调度队列" id="markdown-toc-调度队列">调度队列</a><li><a href="#调度程序" id="markdown-toc-调度程序">调度程序</a><li><a href="#上下文切换context-switch" id="markdown-toc-上下文切换context-switch">上下文切换（Context Switch）</a></ul><li><a href="#进程运行" id="markdown-toc-进程运行">进程运行</a><ul><li><a href="#进程创建" id="markdown-toc-进程创建">进程创建</a><li><a href="#进程终止" id="markdown-toc-进程终止">进程终止</a></ul><li><a href="#进程通信interprocess-communicationipc" id="markdown-toc-进程通信interprocess-communicationipc">进程通信（InterProcess Communication，IPC）</a><ul><li><a href="#共享内存" id="markdown-toc-共享内存">共享内存</a><li><a href="#消息传递" id="markdown-toc-消息传递">消息传递</a><ul><li><a href="#命名" id="markdown-toc-命名">命名</a><li><a href="#同步" id="markdown-toc-同步">同步</a><li><a href="#缓存" id="markdown-toc-缓存">缓存</a></ul><li><a href="#例子" id="markdown-toc-例子">例子</a><ul><li><a href="#posix共享内存" id="markdown-toc-posix共享内存">POSIX共享内存</a><li><a href="#mach" id="markdown-toc-mach">Mach</a><li><a href="#windows" id="markdown-toc-windows">Windows</a></ul><li><a href="#客户机服务器通信" id="markdown-toc-客户机服务器通信">客户机/服务器通信</a><ul><li><a href="#套接字socket" id="markdown-toc-套接字socket">套接字（socket）</a><li><a href="#远程过程调用rpc" id="markdown-toc-远程过程调用rpc">远程过程调用（RPC）</a><li><a href="#管道pipe" id="markdown-toc-管道pipe">管道（pipe）</a><ul><li><a href="#普通管道" id="markdown-toc-普通管道">普通管道</a><li><a href="#命名管道" id="markdown-toc-命名管道">命名管道</a></ul></ul></ul></ul><li><a href="#4-线程" id="markdown-toc-4-线程">4. 线程</a><ul><li><a href="#并行与并发" id="markdown-toc-并行与并发"><strong>并行与并发</strong></a><li><a href="#多线程" id="markdown-toc-多线程">多线程</a><ul><li><a href="#多对一" id="markdown-toc-多对一">多对一</a><li><a href="#一对一" id="markdown-toc-一对一">一对一</a><li><a href="#多对多" id="markdown-toc-多对多">多对多</a></ul><li><a href="#线程库" id="markdown-toc-线程库">线程库</a><li><a href="#隐式多线程implicit-multithreading" id="markdown-toc-隐式多线程implicit-multithreading">隐式多线程（implicit multithreading）</a><ul><li><a href="#线程池" id="markdown-toc-线程池">线程池</a><li><a href="#openmp" id="markdown-toc-openmp">OpenMp</a><li><a href="#大中央调度grand-central-dispatchgcd" id="markdown-toc-大中央调度grand-central-dispatchgcd">大中央调度（Grand Central Dispatch，GCD）</a></ul><li><a href="#多线程问题" id="markdown-toc-多线程问题">多线程问题</a><ul><li><a href="#信号处理" id="markdown-toc-信号处理">信号处理</a><li><a href="#线程撤销thread-cancellation" id="markdown-toc-线程撤销thread-cancellation">线程撤销（thread cancellation）</a><li><a href="#线程本地存储thread-local-storagetls" id="markdown-toc-线程本地存储thread-local-storagetls">线程本地存储（Thread-Local Storage，TLS）</a><li><a href="#调度程序激活" id="markdown-toc-调度程序激活">调度程序激活</a></ul><li><a href="#例子-1" id="markdown-toc-例子-1">例子</a><ul><li><a href="#windows线程" id="markdown-toc-windows线程">Windows线程</a><li><a href="#linux线程" id="markdown-toc-linux线程">Linux线程</a></ul></ul></ul></ul><h1 id="os期末复习">OS期末复习</h1><h2 id="1-introduction"><span class="mr-2">1. Introduction</span><a href="#1-introduction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="os定义"><span class="mr-2">OS<strong>定义</strong></span><a href="#os定义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>一个操作系统是管理计算机硬件的程序，为应用程序提供基础，充当计算机用户和硬件的中介。</p><h3 id="现代计算机硬件组成"><span class="mr-2"><strong>现代计算机硬件组成</strong></span><a href="#现代计算机硬件组成" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="进程processor"><span class="mr-2">进程（processor）</span><a href="#进程processor" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>计算机运行：</p><ol><li>运行初始程序或引导程序（bootstrap program，一般位于ROM只读内存），定位操作系统内核并加载到内核<li>系统程序加到内存便成为系统进程/系统后台程序，生命周期与内核一致。<li>事件发生通过硬件或软件的中断来通知。硬件通过系统总线bus发送信号到CPU，软件通过调用system call与trap触发中断。</ol><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303291855953.png" alt="image-20220621150852905" data-proofer-ignore></p><h4 id="存储"><span class="mr-2">存储</span><a href="#存储" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li>内存（main memory）<ol><li>CPU只能从内存中加载指令，因此执行程序位于内存。<li>内存一般称为RAM，通常为动态随机访问内存DRAM，采用半导体技术实现。也存在ROM内存，只能将静态程序（如引导程序）存在ROM只读内存中。<li>内存具有易失性（volatile），掉电失去所有内容。</ol><li>外存（secondary storage）：磁盘、硬盘、固态硬盘、光盘<li>高速缓存器（Cache）：Cache Coherency (缓存一致性)</ol><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303291855442.png" alt="" data-proofer-ignore></p><p><img data-src="https://raw.githubusercontent.com/JohnnyassSilverhand/typora_images/main/img/202206211355679.png" alt="image-20220621135521170" data-proofer-ignore></p><h4 id="io"><span class="mr-2">IO</span><a href="#io" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li>IO中断驱动：接到I/O请求后，I/O设备传送数据，CPU继续执行用户进程，传送完成后，CPU进行I/O中断处理，处理完成后，再回到用户进程。<img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303291855105.png" alt="image-20220621141647683" data-proofer-ignore><li>直接内存访问（Direct Memory Access，DMA）：外部设备不通过CPU而直接与系统内存交换数据的接口技术。<ol><li>对于一个高速I/O设备，以及批量交换数据的情况，只能采用DMA方式，才能解决效率和速度问题。<li>DMA在外设与内存间直接进行数据交换，而不通过CPU，这样数据传送的速度就取决于存储器和外设的工作速度。<li>通常系统的总线是由CPU管理的。在DMA方式时，就希望CPU把这些总线让出来，即CPU连到这些总线上的线处于第三态–高阻状态，而由DMA控制器接管，控制传送的字节数，判断DMA是否结束，以及发出DMA结束信号。</ol></ol><h3 id="中断"><span class="mr-2">中断</span><a href="#中断" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>中断指计算机CPU获知某些事，暂停正在执行的程序，转而去执行处理该事件的程序，当这段程序执行完毕后再继续执行之前的程序。整个过程称为中断处理，简称中断，而引起这一过程的事件称为中断事件。</p><p>中断是计算机实现并发执行的关键，也是操作系统工作的根本。</p><h4 id="中断的分类"><span class="mr-2"><strong>中断的分类</strong></span><a href="#中断的分类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li>内外部<li>可屏蔽和不可屏蔽<li>同异步</ol><p>中断按事件来源分类，可以分为外部中断（external）和内部中断（internal）。中断事件来自于CPU外部的被称为外部中断，来自于CPU内部的则为内部中断。</p><p>进一步细分，外部中断还可分为可屏蔽中断（maskable interrupt）和不可屏蔽中断（non-maskable interrupt）两种，而内部中断按事件是否正常来划分可分为软中断和异常两种。</p><p>外部中断的中断事件来源于CPU外部，必然是某个硬件产生的，所以外部中断又被称为硬件中断（hardware interrupt）。外部设备的中断信号是通过两根信号线通知CPU的，一根是INTR，另一根是NMI。CPU从INTR收到的中断信号都是不影响系统运行的，CPU可以选择屏蔽（通过设置中断屏蔽寄存器中的IF位），而从NMI中收到的中断信号则是影响中断处理器运行的严重错误，不可屏蔽。</p><p>内部中断来自于处理器内部，其中软中断是由软件主动发起的中断，常被用于系统调用（system call）；而异常则是指令执行期间CPU内部产生的错误引起的。异常也和不可屏蔽中断一样不受eflags寄存器的IF位影响，区别在于不可屏蔽中断发生的事件会导致处理器无法运行（如断电、电源故障等），而异常则是影响系统正常运行的中断（如除0、越界访问等）。</p><p>中断还可以分为同步中断（被称为异常）和异步中断（被称为中断）。</p><p>同步中断是在指令执行时由CPU主动产生的，受到CPU控制，其执行点是可控的。</p><p>异步中断是CPU被动接收到的，由外设发出的电信号引起，其发生时间不可预测。</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303291855706.png" alt="image-20220621135714159" data-proofer-ignore></p><h2 id="2-操作系统结构"><span class="mr-2">2. 操作系统结构</span><a href="#2-操作系统结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="操作系统服务"><span class="mr-2">操作系统服务</span><a href="#操作系统服务" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>用户功能</strong></p><ol><li>用户界面（User Interface，UI）：有命令行界面（Command-Line Interface，CLI）、批处理界面（batch interface），图形用户界面（Graphical User Interface，GUI）。<li>程序执行：系统加载程序到内存并运行。<li>I/O操作<li>文件系统操作<li>通信：通信存在于同一台计算机的两个进程，或通过网络连接的不同计算机进程间。实现方式为共享内存（shared memory）和消息交换（message passing）。<li>错误检测</ol><p><strong>提高系统效率的功能</strong></p><ol><li>资源分配：CPU周期、内存、文件存储、I/O设备<li>记账：记录用户使用资源的类型和数量<li>保护与安全：多用户/网络信息安全；独立进程并发执行时，不干预其他进程或操作系统本身；保护外部I/O设备不受非法访问。</ol><h3 id="用户和程序员接口"><span class="mr-2">用户和程序员接口</span><a href="#用户和程序员接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>系统调用接口</strong></p><p>系统调用（system call）提供操作系统服务接口。</p><p>开发者一般根据应用编程接口（Application Programming Interface，API）来设计程序。这样做的好处是提高程序的可移植性。</p><p>系统调用接口截取API函数的调用，并调用操作系统中的所需系统调用。每个系统调用都有一个相关数字，系统调用接口根据这些数字来建立一个索引列表。</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303291855966.png" alt="image-20220622003953781" data-proofer-ignore></p><p>向操作系统传递参数的方法：</p><ol><li>通过寄存器传递参数<li>将参数存在内存的块或表中，将其地址通过寄存器传递，Linux和Solaris就采用这种方法<li>通过程序放在或压入（push）到堆栈（stack），并通过操作系统弹出（pop）</ol><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303291855007.png" alt="image-20220622004332855" data-proofer-ignore></p><p><strong>系统调用类型</strong></p><ol><li><p>进程控制（process control）</p><p>举例：MS-DOS操作系统是单任务系统，不会创建新进程；FreeBSD（源于Berkeley UNIX）是多任务系统，会启动新进程。</p><p>UNIX函数：fork(), exit(), wait()</p><li><p>文件管理（file manipulation）</p><p>UNIX函数：open(), read(), write()</p><li><p>设备管理（device manipulation）</p><li><p>信息维护（information maintenance）</p><li><p>通信（communication）</p><li><p>保护（protection）</p></ol><h3 id="系统组件"><span class="mr-2">系统组件</span><a href="#系统组件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="简单结构"><span class="mr-2">简单结构</span><a href="#简单结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>MS-DOS系统利用最小空间提供最多功能，没有被划分为模块，没有很好地区分功能的接口和层次。</p><p>UNIX系统由内核和系统程序两个独立部分组成，采用单片结构，系统调用接口之下和物理硬件之上的所有部分可以被视为内核，内核通过系统调用提供操作系统功能。</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303291855927.png" alt="image-20220622005615561" data-proofer-ignore></p><h4 id="微内核"><span class="mr-2">微内核</span><a href="#微内核" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Mach操作系统采用微内核技术对内核进行模块化，从内核中删除所有非必须的部件，将其当作系统级与用户级的程序来实现，因此内核较小。</p><p>微内核的主要功能是，为客户端程序和运行在用户空间中的各种服务提供通信，采用<strong>消息传递</strong>模式。</p><p>微内核的优点之一是便于扩展操作系统，可移植性高。</p><h4 id="模块"><span class="mr-2">模块</span><a href="#模块" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>采用可加载的内核模块（loadable kernel module）：内核提供核心服务，而其它服务可在内核运行时动态实现，动态链接服务优于直接添加新功能到内核。</p><p>这种方法与微内核的区别在于：模块无需调用消息传递来进行通信。</p><p>举例：Solaris，linux</p><h2 id="3-进程"><span class="mr-2">3. 进程</span><a href="#3-进程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="进程概念"><span class="mr-2">进程概念</span><a href="#进程概念" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="进程"><span class="mr-2">进程</span><a href="#进程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>进程是执行的程序，其包括：</p><ol><li>程序代码，或称为文本段（text section）、代码段（code section）<li>当前活动<li>程序计数器（program counter，PC）<li>处理器寄存器内容<li>进程堆栈（stack），包括临时数据（函数参数、返回地址、局部变量）<li>数据段（data section），包括全局变量<li>堆（heap），进程运行时动态分配的内存</ol><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303291855934.png" alt="image-20220623182807322" data-proofer-ignore></p><p>程序是被动实体，当一个可执行文件被加载到内存时，这个程序就成为进程。</p><p>进程本身可以作为一个环境，执行其他代码。例如：<code class="language-plaintext highlighter-rouge">python test.py</code>可以运行该python代码。</p><h4 id="状态"><span class="mr-2">状态</span><a href="#状态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li>new：进程正在创建。<li>running：进程正在执行。<li>waiting：进程等待发生某个事件（I/O完成或收到信号）。<li>ready：进程等待分配处理器<li>terminated：进程已经完成执行。</ol><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303291856480.png" alt="image-20220623183803613" data-proofer-ignore></p><p>一次只有一个进程可在一个处理器上运行；但是许多进程可处于就绪或等待状态。</p><h4 id="进程表process-table"><span class="mr-2"><strong>进程表（Process Table）</strong></span><a href="#进程表process-table" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>进程表是一个内核数据结构，包含用于进程管理、内存管理、文件管理三种数据记录的空间，内核总是有权限访问这三片空间。</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303291855175.png" alt="image-20220623183637491" data-proofer-ignore></p><h4 id="进程控制块prosess-control-blockpcb"><span class="mr-2">进程控制块（Prosess Control Block，PCB）</span><a href="#进程控制块prosess-control-blockpcb" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>操作系统使用进程控制块表示每个进程。操作系统根据PCB管理和控制进程，这是进程存在的标志。</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303291855061.png" alt="image-20220623184339856" data-proofer-ignore></p><h3 id="进程调度process-scheduling"><span class="mr-2">进程调度（Process Scheduling）</span><a href="#进程调度process-scheduling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>分时系统的目标：在进程间快速切换CPU，以便用户在程序运行时能与其交互。</p><h4 id="调度队列"><span class="mr-2">调度队列</span><a href="#调度队列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li>作业队列（job queue）：系统中所有的进程<li>就绪队列（ready queue）：驻留在内存中的、就绪等待运行的进程<li>设备队列（device queue）：等待特定I/O设备的进程列表</ol><h4 id="调度程序"><span class="mr-2">调度程序</span><a href="#调度程序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>无法立即执行的进程会被保存到大容量存储设备（如磁盘）的缓冲池。</p><ol><li>长期调度程序/作业调度程序：从缓冲池中选择进程，加载到内存（加入就绪队列）。长期调度进程控制多道程序程度（内存中的进程数量），从I/O密集型进程和CPU密集型进程中选择。<li>短期调度程序/CPU调度程序：从准备执行的进程（就绪队列）中选择进程，分配CPU<li>中期调度程序（交换）：将进程从内存中移出，从而降低多道程序程度。此后，进程可被重新调入内存，并从中断处继续执行。</ol><p>长期与短期调度程序主要区别是执行频率。</p><h4 id="上下文切换context-switch"><span class="mr-2">上下文切换（Context Switch）</span><a href="#上下文切换context-switch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>中断发生时，CPU从执行当前任务改变到执行内核程序（从用户到内核），系统需要保存当前运行进程的上下文，以便恢复进程。</p><p>进程上下文用PCB表示。内核将旧进程状态保存在其PCB中，然后加载经调度而要执行的新进程的上下文。</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303291856522.png" alt="image-20220623220827167" data-proofer-ignore></p><h3 id="进程运行"><span class="mr-2">进程运行</span><a href="#进程运行" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>相关函数：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="c1">//得到进程的PID</span>
<span class="n">pid_t</span> <span class="nf">getpid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="c1">//得到进程的PPID</span>
<span class="n">pid_t</span> <span class="nf">getppid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="c1">//创建进程</span>
<span class="n">pid_t</span> <span class="nf">fork</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="c1">//对父进程返回0，对子进程返回一个比大于0的pid，失败则返回小于0的数</span>
<span class="n">pid_t</span> <span class="nf">vfork</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="c1">//替换进程</span>
<span class="kt">int</span> <span class="nf">execv</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">constargv</span><span class="p">[]);</span> 
<span class="c1">//终止进程</span>
<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">//回收子进程</span>
<span class="n">pid_t</span> <span class="nf">wait</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</pre></table></code></div></div><h4 id="进程创建"><span class="mr-2">进程创建</span><a href="#进程创建" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>父进程创建新的子进程，每个新进程可以再创建其他进程，从而形成进程树。多数操作系统采用唯一进程标识符（process identifier，PID）来作为进程索引，访问内核中进程的各种属性。</p><p>在Linux系统中（相比进程，linux偏爱task这个术语），<strong>进程init</strong>的PID总是1，作为所有用户进程的根进程或父进程。init进程是linux内核启动后第一个执行的进程，作为引导程序，启动守护进程并且运行必要的程序。</p><p>对于UNIX和Linux系统，可以通过<code class="language-plaintext highlighter-rouge">ps</code>命令得到进程列表。</p><p>当一个进程创建子进程：</p><ol><li>子进程可以从两处获取资源（CPU时间、内存、文件、I/O设备等）：<ol><li>操作系统<li>父进程（除了逻辑资源，子进程从父进程获取参数初始化）</ol><li>父子进程的执行顺序：<ol><li>父进程与子进程并发执行<li>父进程等待，直到某个或全部子进程执行完</ol><li>父子进程的地址空间：<ol><li>子进程是父进程的复制品<ol><li>子进程拷贝父进程的地址空间，与父进程具有同样的程序和数据副本，虚拟映射地址一致，物理地址不一致<li>子进程共享父进程的地址空间，虚拟映射地址一致，物理地址一致</ol><li>子进程加载另一个新程序（<code class="language-plaintext highlighter-rouge">exec()</code>可进行进程替换）</ol></ol><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303291856239.png" alt="image-20220623195212130" data-proofer-ignore></p><h4 id="进程终止"><span class="mr-2">进程终止</span><a href="#进程终止" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>级联终止（Cascading Termination）</strong>：有些系统不允许子进程在父进程已经终止的情况下存在。如果一个进程终止，那么它的所有子进程也应终止，这种现象成为级联终止，通常由操作系统启动。</p><p>父进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。</p><p>假如父进程没有调用wait()就终止，子进程会成为孤儿进程，其PCB包含了进程的退出状态，一直被保留在进程表中，无法释放。Linux和UNIX会将init进程作为孤儿进程的父进程。进程init定期调用wait()，收集任何孤儿进程的退出状态，释放PID和进程表条目。</p><h3 id="进程通信interprocess-communicationipc"><span class="mr-2">进程通信（InterProcess Communication，IPC）</span><a href="#进程通信interprocess-communicationipc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>操作系统内并发执行进程可以是独立或协作的。协作进程需要有一种IPC机制。</p><p>进程间通信有两种基本模型：</p><ol><li>共享内存。共享内存系统仅需要在建立共享内存区域时需要系统调用，一旦建立共享内存，所有访问无需借助内核。但对于多核系统而言，共享内存具有高速缓存一致性的问题。<li>消息传递。消息传递的实现经常采用系统调用，需要消耗更多时间使内核介入。但对于多核系统而言，消息传递的性能更高。</ol><h4 id="共享内存"><span class="mr-2">共享内存</span><a href="#共享内存" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>生产者-消费者</p><p>缓冲区分为无界缓冲区和有界缓冲区。</p><h4 id="消息传递"><span class="mr-2">消息传递</span><a href="#消息传递" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="命名"><span class="mr-2">命名</span><a href="#命名" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ol><li><p>直接通信：需要通信的每个进程必须明确指示通信的接收者或发送者。</p><ol><li>对称寻址：发送和接受一对一。<li>非对称寻址：发送者指定接收者。</ol><p>缺点：生成进程定义的有限模块化。</p><li><p>间接通信：通过邮箱或端口作为中介来发送和接受消息，其可归属于操作系统或进程。</p></ol><p>最基本的通信原语有两条,它们是send原语和receive原语。send(M,N)中，M为信箱名</p><h5 id="同步"><span class="mr-2">同步</span><a href="#同步" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>阻塞和非阻塞</p><p>同步和异步</p><h5 id="缓存"><span class="mr-2">缓存</span><a href="#缓存" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>通信进程交换的消息总是驻留在临时队列中。</p><p>根据容量分类：</p><ol><li>零容量<li>有限容量<li>无限容量</ol><h4 id="例子"><span class="mr-2">例子</span><a href="#例子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="posix共享内存"><span class="mr-2">POSIX共享内存</span><a href="#posix共享内存" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h5 id="mach"><span class="mr-2">Mach</span><a href="#mach" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>内核通过内核邮箱与任务通信，将事件发生的通知发送到通知邮箱。消息结构：固定大小的头部（消息长度、发送端口、接收端口）和可变大小的数据。</p><h5 id="windows"><span class="mr-2">Windows</span><a href="#windows" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h4 id="客户机服务器通信"><span class="mr-2">客户机/服务器通信</span><a href="#客户机服务器通信" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>客户机/服务器系统除了利用共享内存和消息传递进行通信，还有以下三种策略：</p><h5 id="套接字socket"><span class="mr-2">套接字（socket）</span><a href="#套接字socket" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>每个套接字由一个IP地址和一个端口号组成。</p><ol><li>客户进程发出连接请求，其主机为其分配一个端口。这个端口是大于1024的某个数字。<li>服务器调用<code class="language-plaintext highlighter-rouge">accpet()</code>监听端口。<li>客户端创建一个套接字，连接到服务器监听的端口。</ol><p>套接字属于分布式进程之间的一种低级形式的通信，其中一个原因是，只允许在通信线程之间交换无结构的字节流。</p><h5 id="远程过程调用rpc"><span class="mr-2">远程过程调用（RPC）</span><a href="#远程过程调用rpc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>中介子函数转发</p><h5 id="管道pipe"><span class="mr-2">管道（pipe）</span><a href="#管道pipe" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><h6 id="普通管道">普通管道</h6><p>普通管道是单向无名管道。</p><ol><li>对于UNIX系统，子进程自动继承由父进程创建的管道。<li>对于Windows系统，程序员需要指定子进程继承的属性。<li>对于Windows和UNIX系统，采用普通管道通信的进程需要有父子关系，这说明这些管道只可用于同一机器的进程间通信。<li>对于Windows和UNIX系统，一旦进程已经完成通信并终止，普通管道就不存在了。</ol><h6 id="命名管道">命名管道</h6><p>命名管道可以是双向管道，其进程间的父子关系不必须，但必须存在同一机器上；当通信进程完成后，命名管道继续存在。</p><p>对于UNIX系统，命名管道为FIFO，一旦创建即表现为文件系统的典型文件，可以通过系统调用读写文件。FIFO一经创建会一直存在，直到被显式删除文件。FIFO只允许半双工传输。</p><p>对于Windows系统，允许全双工通信，且通信进程可以位于同一机器或不同机器。</p><ul><li>单工：简单的说就是一方只能发信息，另一方则只能收信息，通信是单向的。<li>半双工：比单工先进一点，就是双方都能发信息，但同一时间则只能一方发信息。<li>全双工：比半双工再先进一点，就是双方不仅都能发信息，而且能够同时发送。</ul><p>管道经常用于将一个命令的输出作为另一个命令的输入，例如：<code class="language-plaintext highlighter-rouge">ls | more</code>（UNIX命令行）、<code class="language-plaintext highlighter-rouge">dir | more</code>（Windows命令行）</p><h2 id="4-线程"><span class="mr-2">4. 线程</span><a href="#4-线程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>每个线程是CPU使用的一个基本单元，其包括线程ID、程序计数器PC，寄存器组和堆栈，与同一进程的其他线程共享代码段、数据段和文件等其他操作系统资源。</p><div class="table-wrapper"><table><thead><tr><th>代码<th>数据<th>文件<tbody><tr><td>线程1的寄存器组<td>线程2的寄存器组<td>线程3的寄存器组<tr><td>线程1的堆栈<td>线程2的堆栈<td>线程3的堆栈<tr><td>线程1的ID、PC及活动内容<td>线程2的ID、PC及活动内容<td>线程3的ID、PC及活动内容</table></div><p>传统或重量级进程（Heavy Weight Process，HWP）只有单个控制线程。例如，进程创建是重量级进程，而线程创建是轻量级进程。</p><p>进程与线程的关系：</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303291856889.png" alt="image-20220625095849030" data-proofer-ignore></p><p>线程的优点：</p><ol><li>响应快<li>线程默认共享他们所属进程的内存和资源<li>创建和切换线程更加经济<li>具有可伸缩性，线程可在多处理器核上并行运行</ol><h3 id="并行与并发"><span class="mr-2"><strong>并行与并发</strong></span><a href="#并行与并发" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>处理核只能同一时间执行单个线程。多核（multicore）系统/多处理器（multiprocessor）系统能够并行运行，因为系统可以为每个核分配一个单独线程。而单处理器系统只能并发运行。</p><ul><li>并行：同时执行多个任务<ul><li>数据并行：将数据分布于多个计算核上，并在每个核上执行相同操作<li>任务并行：将线程而不是数据分配到多个计算核，每个线程并行执行独特的操作。</ul><li>并发：支持多个任务，允许所有任务都取得进展；线程能够交错执行。</ul><p>CPU调度器通过快速切换进程，以便每个进程取得进展，造成并行的假象。</p><p>Amdahl定律：\(加速比 ≤ \frac{1}{S+\frac{1-S}{N}}\)，其中，S为应用程序中串行执行的占比，1-S自然为并行执行的占比，该系统具有N个处理器核。</p><h3 id="多线程"><span class="mr-2">多线程</span><a href="#多线程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>用户线程位于内核之上，管理无需内核支持；而内核线程由操作系统直接支持和管理。</p><h4 id="多对一"><span class="mr-2">多对一</span><a href="#多对一" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>多对一模型映射多个用户级线程到一个内核线程。</p><p>优点：线程管理由用户空间的线程库完成，效率较高。</p><p>缺点：一个线程阻塞，整个进程阻塞；该线程无法并行运行在多处理核系统上。</p><h4 id="一对一"><span class="mr-2">一对一</span><a href="#一对一" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>一对一模型映射每个用户线程到一个内核线程。</p><p>优点：提供并发性；允许多个线程并行运行在多处理器系统上。</p><p>缺点：创建一个用户线程就要创建一个相应的内核线程，开销影响性能，实现需要限制系统支持的线程数量。</p><h4 id="多对多"><span class="mr-2">多对多</span><a href="#多对多" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>多对多模型多路复用多个用户级线程到同样数量或更少的内核线程。（内核线程数≤用户级线程数）</p><p>优点：可以创建任意多的用户线程，且内核线程能在多处理器系统上并发执行。</p><p>该模型的亚种是双层模型（tow-level model），允许绑定某个用户线程到一个内核线程。</p><h3 id="线程库"><span class="mr-2">线程库</span><a href="#线程库" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>线程库（thread library）为程序员提供创建和管理线程的API。</p><p>实现方法：</p><ol><li>在用户空间内提供一个没有内核支持的库，所有代码和数据结构都位于用户空间，调用库内的函数只是用户空间的本地调用而非系统调用<li>实现由操作系统直接支持的内核级的一个库，所有代码和数据结构都位于内核空间，调用库内API函数会导致系统调用</ol><p>目前主要使用的线程库：</p><ol><li>POSIX Pthreads，可提供用户级或内核级的库；全局声明数据可以为同一进程的所有线程共享<li>Windows，可提供内核级的库；全局声明数据可以为同一进程的所有线程共享<li>Java，采用宿主系统的线程库来实现；线程对共享数据的访问需要显式安排</ol><p><strong>多线程创建的常用策略</strong></p><ol><li>异步线程：父线程创建子线程后即恢复自身运行，与子线程并发执行，相互独立，很少数据共享<li>同步线程：父线程在回复执行前等待所有子线程的终止，通常涉及大量数据共享，例如由父进程组合输出子线程计算的结果</ol><h3 id="隐式多线程implicit-multithreading"><span class="mr-2">隐式多线程（implicit multithreading）</span><a href="#隐式多线程implicit-multithreading" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>将多线程的创建管理交给编译器和运行时的库来完成，这种策略称为隐式线程。</p><h4 id="线程池"><span class="mr-2">线程池</span><a href="#线程池" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>线程池的主要思想：在进程开始时创建一定数量的线程，并加到池中等待工作。当服务器收到请求，其唤醒池内的可用线程传递请求，一旦线程完成服务，回到池中等待工作。如果池中没有可用线程，那么服务器会等待。</p><p>线程池的优点：</p><ol><li>高效。用现有程序服务请求比等待创建线程更快。<li>限制了任何时候可用线程的数量，保障了容量安全<li>允许采用不同策略运行任务</ol><h4 id="openmp"><span class="mr-2">OpenMp</span><a href="#openmp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h4 id="大中央调度grand-central-dispatchgcd"><span class="mr-2">大中央调度（Grand Central Dispatch，GCD）</span><a href="#大中央调度grand-central-dispatchgcd" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h3 id="多线程问题"><span class="mr-2">多线程问题</span><a href="#多线程问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="信号处理"><span class="mr-2">信号处理</span><a href="#信号处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>UNIX信号用于通知进程某个特定事件已发生。其模式为：特定事件的发生产生了信号-&gt;信号被传递给某个进程-&gt;进程一旦接收到信号就应处理</p><p>信号的接收是同步还是异步，取决于事件信号的来源和原因。</p><ol><li>当一个信号由运行程序以外的事件产生，该进程就异步接收这一信号。<li>同步信号发送到由于导致该信号的同一进程。</ol><p>信号处理程序有：</p><ol><li>缺省的信号处理程序<li>用户定义的信号处理程序</ol><p>例如<code class="language-plaintext highlighter-rouge">ptrhread_kill()</code></p><h4 id="线程撤销thread-cancellation"><span class="mr-2">线程撤销（thread cancellation）</span><a href="#线程撤销thread-cancellation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>线程撤销是在线程完成之前终止线程。</p><ol><li>异步撤销：一个线程立即终止目标线程（他杀）；可能会不会释放必要的系统资源。<li>延迟撤销：目标线程不断检查它是否应终止，这允许目标线程有机会有序终止自己（教唆自杀）</ol><h4 id="线程本地存储thread-local-storagetls"><span class="mr-2">线程本地存储（Thread-Local Storage，TLS）</span><a href="#线程本地存储thread-local-storagetls" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>每个线程独有的本地数据叫线程本地存储。其与局部变量的区别是，局部变量只在单个函数调用时才可见，而TLS数据在多个函数调用时都可见。TLS类似于静态static数据。</p><h4 id="调度程序激活"><span class="mr-2">调度程序激活</span><a href="#调度程序激活" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>调度器激活（scheduler activation）是用户线程库与内核之间的一种通信方案，内核提供一组虚拟处理器（LWP）给应用程序，而应用程序调度用户线程到任何可用的虚拟处理器。内核将有关特定时间通知应用程序，该步骤称为回调（upcall），由线程库通过回调处理程序（upcall handler）来处理。</p><h3 id="例子-1"><span class="mr-2">例子</span><a href="#例子-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="windows线程"><span class="mr-2">Windows线程</span><a href="#windows线程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>线程一般包括：</p><ol><li>线程ID，TID<li>寄存器组<li>用户堆栈，内核堆栈<li>私有存储区域，用于各种运行时库和动态链接库（DLL）</ol><p>后三种部件通常称为线程上下文（context）。</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303291856036.png" alt="image-20220625132351957" data-proofer-ignore></p><h4 id="linux线程"><span class="mr-2">Linux线程</span><a href="#linux线程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://blog.csdn.net/qq_21989927/article/details/109801283">批处理系统、分时系统、实时操作系统的特点和比较_马小超i的博客-CSDN博客_分时系统,实时系统,批处理系统</a></p><p><a href="https://blog.csdn.net/guangod/article/details/109559530?ops_request_misc=%7B%22request%5Fid%22%3A%22165640638816781683953155%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=165640638816781683953155&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-109559530-null-null.142^v24^huaweicloudv2,157^v15^new_3&amp;utm_term=PV操作&amp;spm=1018.2226.3001.4187">操作系统考点之PV操作、信号量_guangod的博客-CSDN博客_操作系统信号量pv操作</a></p><p><a href="https://blog.csdn.net/qq_32623363/article/details/87891224?ops_request_misc=%7B%22request%5Fid%22%3A%22165640727216782391840367%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=165640727216782391840367&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-87891224-null-null.142^v24^huaweicloudv2,157^v15^new_3&amp;utm_term=进程七态&amp;spm=1018.2226.3001.4187">操作系统进程状态模型__吟游诗人的博客-CSDN博客_进程的七状态模型</a></p><p><a href="https://blog.csdn.net/qq_36383623/article/details/106891036?ops_request_misc=%7B%22request%5Fid%22%3A%22165640697916782248534608%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=165640697916782248534608&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-106891036-null-null.142^v24^huaweicloudv2,157^v15^new_3&amp;utm_term=多道程序设计&amp;spm=1018.2226.3001.4187">操作系统之多道程序设计_莫之的博客-CSDN博客_多道程序设计</a></p><p><a href="https://blog.csdn.net/m0_56578216/article/details/125107098?ops_request_misc=%7B%22request%5Fid%22%3A%22165640811116782390552240%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=165640811116782390552240&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-125107098-null-null.142^v24^huaweicloudv2,157^v15^new_3&amp;utm_term=响应比最高者优先算法&amp;spm=1018.2226.3001.4187">最高响应比优先算法（HRRF）及例题详解_EMT00923的博客-CSDN博客_响应比高者优先调度算法例题</a></p><p><a href="https://blog.csdn.net/weixin_38337701/article/details/89974533?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=进程调度算法评估&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-89974533.142^v24^huaweicloudv2,157^v15^new_3&amp;spm=1018.2226.3001.4187">进程典型七大调度算法_emcpper的博客-CSDN博客_常见的进程调度算法有哪些</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/courses/'>Courses</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/os/" class="post-tag no-text-decoration" >OS</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=OS+Outline+-+CyberWitch&url=https%3A%2F%2Fwitchpuff.github.io%2Fposts%2Fos%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=OS+Outline+-+CyberWitch&u=https%3A%2F%2Fwitchpuff.github.io%2Fposts%2Fos%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fwitchpuff.github.io%2Fposts%2Fos%2F&text=OS+Outline+-+CyberWitch" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="http://service.weibo.com/share/share.php?title=OS+Outline+-+CyberWitch&url=https%3A%2F%2Fwitchpuff.github.io%2Fposts%2Fos%2F" data-toggle="tooltip" data-placement="top" title="Weibo" target="_blank" rel="noopener" aria-label="Weibo"> <i class="fa-fw fab fa-weibo"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/transport/">Computer Network: Transport Layer(2)</a><li><a href="/posts/classification/">Machine Learning: Classification</a><li><a href="/posts/sqlite3/">ModuleNotFoundError: No module named '_sqlite3'解决方法</a><li><a href="/posts/clustering/">Machine Learning: Clustering</a><li><a href="/posts/astar/">Solving 15-Puzzle with A* and IDA*</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/computer-network/">Computer Network</a> <a class="post-tag" href="/tags/machine-learning/">Machine Learning</a> <a class="post-tag" href="/tags/bart/">BART</a> <a class="post-tag" href="/tags/music-generation/">Music Generation</a> <a class="post-tag" href="/tags/searching/">Searching</a> <a class="post-tag" href="/tags/a/">A*</a> <a class="post-tag" href="/tags/clustering/">Clustering</a> <a class="post-tag" href="/tags/cnn/">CNN</a> <a class="post-tag" href="/tags/computer-architecture/">Computer Architecture</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/classification/"><div class="card-body"> <em class="small" data-ts="1667871390" data-df="ll" > Nov 8, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Machine Learning: Classification</h3><div class="text-muted small"><p> 基于CIFAR-10图像分类任务训练线性分类器、MLP和CNN模型 一、模型原理 1）Softmax分类器 2）MLP 3）CNN 4）网络参数 1、CUDA加速 2、损失函数 ...</p></div></div></a></div><div class="card"> <a href="/posts/clustering/"><div class="card-body"> <em class="small" data-ts="1671327390" data-df="ll" > Dec 18, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Machine Learning: Clustering</h3><div class="text-muted small"><p> 机器学习：K-Means&amp;amp;GMM学习笔记 1、K-Means 1）算法思路 2）初始化中心点 1. 随机选取k个中心点 2. 最大距离选取中心点 ...</p></div></div></a></div><div class="card"> <a href="/posts/computerArchitecture/"><div class="card-body"> <em class="small" data-ts="1673660190" data-df="ll" > Jan 14, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>计算机体系结构文献综述</h3><div class="text-muted small"><p> 体系结构在大规模机器学习的应用 Introduction A Software-defined Tensor Streaming Multiprocessor for Large-scale Machine Learning 确定性执行与向外扩展的保证 网络拓扑结构 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/picgo/" class="btn btn-outline-primary" prompt="Older"><p>picgo报错Error: connect ECONNREFUSED 127.0.0.1:443的解决方式</p></a> <a href="/posts/svm/" class="btn btn-outline-primary" prompt="Newer"><p>SVM学习笔记</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "WitchPuff/WitchPuff.github.io", "data-repo-id": "R_kgDOHwS97Q", "data-category": "Announcements", "data-category-id": "DIC_kwDOHwS97c4CQnTG", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="">WitchPuff</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/computer-network/">Computer Network</a> <a class="post-tag" href="/tags/machine-learning/">Machine Learning</a> <a class="post-tag" href="/tags/bart/">BART</a> <a class="post-tag" href="/tags/music-generation/">Music Generation</a> <a class="post-tag" href="/tags/searching/">Searching</a> <a class="post-tag" href="/tags/a/">A*</a> <a class="post-tag" href="/tags/clustering/">Clustering</a> <a class="post-tag" href="/tags/cnn/">CNN</a> <a class="post-tag" href="/tags/computer-architecture/">Computer Architecture</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
