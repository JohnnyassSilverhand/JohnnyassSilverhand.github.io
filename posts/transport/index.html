<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="en"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Computer Network: Transport Layer(2)" /><meta property="og:locale" content="en" /><meta name="description" content="A minimal, responsive, and powerful Jekyll theme for presenting professional writing." /><meta property="og:description" content="A minimal, responsive, and powerful Jekyll theme for presenting professional writing." /><link rel="canonical" href="https://witchpuff.github.io/posts/transport/" /><meta property="og:url" content="https://witchpuff.github.io/posts/transport/" /><meta property="og:site_name" content="CyberWitch" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-02-11T09:40:30+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Computer Network: Transport Layer(2)" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-03-30T15:26:12+08:00","datePublished":"2023-02-11T09:40:30+08:00","description":"A minimal, responsive, and powerful Jekyll theme for presenting professional writing.","headline":"Computer Network: Transport Layer(2)","mainEntityOfPage":{"@type":"WebPage","@id":"https://witchpuff.github.io/posts/transport/"},"url":"https://witchpuff.github.io/posts/transport/"}</script><title>Computer Network: Transport Layer(2) | CyberWitch</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="CyberWitch"><meta name="application-name" content="CyberWitch"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img class="avatar" alt="WitchPuff" width="100" height="100" data-proofer-ignore="true" src="https://avatars2.githubusercontent.com/WitchPuff?v=3&s=100" srcset="https://avatars2.githubusercontent.com/WitchPuff?v=3&s=100 1x, https://avatars2.githubusercontent.com/WitchPuff?v=3&s=200 2x, https://avatars2.githubusercontent.com/WitchPuff?v=3&s=300 3x, https://avatars2.githubusercontent.com/WitchPuff?v=3&s=400 4x" /> </a></div><div class="site-title mt-3"> <a href="/">CyberWitch</a></div><div class="site-subtitle font-italic">A Room of One's Own</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/WitchPuff" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['ttqsjzsq','163.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Computer Network: Transport Layer(2)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Computer Network: Transport Layer(2)</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1676079630" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Feb 11, 2023 </em> </span> <span> Updated <em class="" data-ts="1680161172" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Mar 30, 2023 </em> </span><div class="d-flex justify-content-between"> <span> By <em> WitchPuff </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7286 words"> <em>40 min</em> read</span></div></div></div><div class="post-content"><ul id="markdown-toc"><li><a href="#transport-layer" id="markdown-toc-transport-layer">Transport Layer</a><ul><li><a href="#transport-layer-services" id="markdown-toc-transport-layer-services">Transport-Layer Services</a><ul><li><a href="#multiplexing--demultiplexing" id="markdown-toc-multiplexing--demultiplexing">Multiplexing &amp; Demultiplexing</a><li><a href="#udp" id="markdown-toc-udp">UDP</a><li><a href="#rdt" id="markdown-toc-rdt">RDT</a><li><a href="#tcp" id="markdown-toc-tcp">TCP</a></ul><li><a href="#1-transport-layer-services" id="markdown-toc-1-transport-layer-services">1. Transport-Layer Services</a><ul><li><a href="#11-transport-layer-protocols" id="markdown-toc-11-transport-layer-protocols">1.1 Transport layer protocols</a><li><a href="#12-network-layer-protocols" id="markdown-toc-12-network-layer-protocols">1.2 Network Layer protocols</a></ul><li><a href="#2-multiplexing--demultiplexing" id="markdown-toc-2-multiplexing--demultiplexing">2. Multiplexing &amp; Demultiplexing</a><ul><li><a href="#21-definition" id="markdown-toc-21-definition">2.1 definition</a><li><a href="#22-multiplexing--demultiplexing-in-udp" id="markdown-toc-22-multiplexing--demultiplexing-in-udp">2.2 Multiplexing &amp; Demultiplexing in UDP</a><li><a href="#23-multiplexing--demultiplexing-in-tcp" id="markdown-toc-23-multiplexing--demultiplexing-in-tcp">2.3 Multiplexing &amp; Demultiplexing in TCP</a><li><a href="#24-security" id="markdown-toc-24-security">2.4 Security</a></ul><li><a href="#3-udpuser-datagram-protocol" id="markdown-toc-3-udpuser-datagram-protocol">3. UDP(User Datagram Protocol)</a><ul><li><a href="#31-udp-segment-structure" id="markdown-toc-31-udp-segment-structure">3.1 UDP segment structure</a><ul><li><a href="#311-checksum" id="markdown-toc-311-checksum">3.1.1 checksum</a></ul><li><a href="#32-applications-running-on-udp" id="markdown-toc-32-applications-running-on-udp">3.2 Applications running on UDP</a></ul><li><a href="#4-reliable-data-transfer" id="markdown-toc-4-reliable-data-transfer">4. Reliable Data Transfer</a><ul><li><a href="#41-rdt10" id="markdown-toc-41-rdt10">4.1 rdt1.0</a><li><a href="#42-rdt20" id="markdown-toc-42-rdt20">4.2 rdt2.0</a><ul><li><a href="#422-rdt21" id="markdown-toc-422-rdt21">4.2.2 rdt2.1</a><li><a href="#422-rtd22" id="markdown-toc-422-rtd22">4.2.2 rtd2.2</a></ul><li><a href="#43-rdt30" id="markdown-toc-43-rdt30">4.3 rdt3.0</a><li><a href="#44-pipelined-reliable-data-transfer-protocols" id="markdown-toc-44-pipelined-reliable-data-transfer-protocols">4.4 Pipelined Reliable Data Transfer Protocols</a><ul><li><a href="#441-go-back-n" id="markdown-toc-441-go-back-n">4.4.1 Go Back N</a><li><a href="#442-selective-repeat" id="markdown-toc-442-selective-repeat">4.4.2 Selective Repeat</a></ul></ul><li><a href="#5-tcptransmission-control-protocol" id="markdown-toc-5-tcptransmission-control-protocol">5. TCP(Transmission Control Protocol)</a><ul><li><a href="#51-definition" id="markdown-toc-51-definition">5.1 Definition</a><ul><li><a href="#features" id="markdown-toc-features">Features</a><li><a href="#mss-mtu-tcp-segment-size" id="markdown-toc-mss-mtu-tcp-segment-size">MSS, MTU, TCP segment size</a><li><a href="#tcp-segment-structure" id="markdown-toc-tcp-segment-structure">TCP segment structure</a></ul><li><a href="#52-rtt-estimation-and-timeout" id="markdown-toc-52-rtt-estimation-and-timeout">5.2 RTT Estimation and Timeout</a><li><a href="#53-rdt-service-in-tcp" id="markdown-toc-53-rdt-service-in-tcp">5.3 RDT service in TCP</a><ul><li><a href="#快速重传" id="markdown-toc-快速重传">快速重传</a></ul><li><a href="#54-flow-control" id="markdown-toc-54-flow-control">5.4 FLow Control</a><li><a href="#55-connection-management" id="markdown-toc-55-connection-management">5.5 Connection Management</a><ul><li><a href="#3-way-handshake" id="markdown-toc-3-way-handshake">3-way handshake</a><li><a href="#close" id="markdown-toc-close">close</a><li><a href="#syn-flood-attack---classic-dos-attack" id="markdown-toc-syn-flood-attack---classic-dos-attack">SYN flood attack - classic Dos attack</a></ul><li><a href="#56-congestion-control" id="markdown-toc-56-congestion-control">5.6 Congestion Control</a><ul><li><a href="#tcp-congestion-control" id="markdown-toc-tcp-congestion-control">TCP Congestion Control</a><ul><li><a href="#限制流量速率" id="markdown-toc-限制流量速率">限制流量速率</a><li><a href="#感知拥塞" id="markdown-toc-感知拥塞">感知拥塞</a><li><a href="#拥塞控制算法" id="markdown-toc-拥塞控制算法">拥塞控制算法</a></ul></ul></ul></ul></ul><h1 id="transport-layer">Transport Layer</h1><h3 id="transport-layer-services"><span class="mr-2">Transport-Layer Services</span><a href="#transport-layer-services" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>相比运行在hosts（IP地址）之间的网络层协议，传输层协议运行在不同hosts的processes之间，实现logical communication，且其部署在end systems中而非routers中。网络层协议有UDP与TCP，两者都提供多路复用/解复用与错误检测的服务，但TCP还提供可靠数据传输、流控制、拥塞控制的服务。</p><h4 id="multiplexing--demultiplexing"><span class="mr-2">Multiplexing &amp; Demultiplexing</span><a href="#multiplexing--demultiplexing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>在多主机、多应用、多进程、多socket上，不同应用间的通信是通过segment在socket中传输实现的，多路复用/解复用就用于定位一个segment的目的socket与源socket是什么，解复用是发送至socket，多路复用是从socket接收并发至网络层，这通过两者实现：1）唯一标识符socket，2）segment中指定源与目的socket <strong>port number</strong>。UDP socket只关注目的地，而TCP socket由于面向连接，会建立源-目的地的一对一连接。</p><h4 id="udp"><span class="mr-2">UDP</span><a href="#udp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>UDP header中有源端口号、目的端口号（用于多路复用/解复用），length与checksum（提供data integrity服务，将16bit data相加后取反，进位时最低位+1，接收时data+checksum全为1则说明无误）。使用UDP的应用有：DNS（实时性、无需连接、减小内存占用、UDP header字节更少更轻量），SNMP，NFS。</p><h4 id="rdt"><span class="mr-2">RDT</span><a href="#rdt" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li>rdt1.0：假设信道完全可靠，接收方无需任何feedback。<li>rdt2.x：假设信道存在bit error，即packet可能受损但不丢包。<ol><li>rdt2.0：接收方采用ACK, NAK, ARQ，接收方确认收到传送ACK，出错传送NAK，发送方收到NAK则重传。<li>rdt2.1：假设ACK/NAK packet也可能受损，发送方只要收到受损的feedback packet就重传，为排除冗余packet，为数据packet添加单bit序号字段1/0，接收方使用ACK, NAK 1/0。<li>rdt2.2：接收方移除NAK，采用ACK 1/0。</ol><li>rdt3.0：假设信道存在bit error且lossy，即packet可能受损或可能丢包，发送方发送每个packet时启动<strong>定时器</strong>，超时则重传，接收方使用ACK 1/0。<li>pipelined：rdt协议的缺陷是由于其核心为<strong>停等协议</strong>，每次传输都至少要等待一个RTT，因此采用流水线设计，不需要等待前序packet被确认收到。<ol><li>Go Back N：序号范围扩大，双方都需要维持缓冲区。发送方维护<strong>一个全局计时器</strong>和一个窗口(base,nextseqnum)，base为最小未确认packet的序号，每次更新base时重启计时器，<strong>超时重传当前窗口所有未确认的分组</strong>。接收方采用<strong>累计确认</strong>ACK k，不符合当前需求序号k的packet一律丢弃，即接收方保证正确、正序确认packet。<li>Selective Repeat：双方都维持缓冲区和窗口，且由于feedback的延迟或丢包，窗口不同步。发送方<strong>为每个分组维持一个定时器</strong>，超时重传。接收方只要确认收到当前窗口和上一窗口范围内的分组，就发送ACK k（即使冗余），防止由于ACK丢失，发送方一直重传。</ol></ol><h4 id="tcp"><span class="mr-2">TCP</span><a href="#tcp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>TCP的特征为面向连接（体现在3次握手）、全双工、点对点（多重广播）、双向传输。</p><p>TCP的连接管理：</p><ol><li>3次握手：client开辟连接，发送SYN segment（SYN=1)，server发送SYNACK segment（单独ACK不包含任何数据，不是捎带确认，该确认segment中会给予该SYN segment一个cookie，此时不开辟连接，防止SYN flood attack），client发送ACK segment，可能包含请求数据，收到后server开辟连接。<li>关闭连接：client发送FIN segment（FIN=1）请求关闭，server发送ACK确认后一段时间再发送FIN segment，client确认后，两端真正关闭连接。</ol><p>TCP提供RDT、流控制、拥塞控制服务。</p><ol><li>RDT：发送方维持一个定时器，超时重传，并累计确认，收到冗余ACK就快速重传，无需等到超时。<li>流控制：在header中维持一个receive window（用最后读取、最后接收、最后发送、最后确认与buffer size来表示）。<li>拥塞控制：<ol><li>通过cwnd控制速度；<li>丢包（超时/冗余ACK x3）视为拥堵，收到一个ACK则增大cwnd，pushy strategy；<li>拥塞控制算法：初始cwnd=MSS，慢启动（cwnd+=MSS，指数增长）、拥塞避免（cwnd+=MSS*MSS/cwnd，线性增长）、快速恢复（cwnd+=MSS，指数增长），只要丢包（timeout/duplicate ACK）ssthresh=cwnd/2（乘性减半）且重传，超时则重启慢启动，冗余ACK则cwnd=ssthresh+3MSS，进入快速恢复，直到首次收到新的ACK，视为拥塞结束，进入拥塞避免。</ol></ol><h2 id="1-transport-layer-services"><span class="mr-2">1. Transport-Layer Services</span><a href="#1-transport-layer-services" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Conclusion：相比运行在hosts（IP地址）之间的网络层协议，传输层协议运行在不同hosts的processes之间，实现logical communication，且其部署在end systems中而非routers中。网络层协议有UDP与TCP，两者都提供多路复用/解复用与错误检测的服务，但TCP还提供可靠数据传输、流控制、拥塞控制的服务。</p><p>服务：传输层协议提供了运行在不同hosts上运行的<strong>processes</strong>实现逻辑通信logical communication（指他们在逻辑上直接连接，但实际上可能经过了无数routers）。相对的，一个网络层协议在<strong>hosts</strong>之间实现逻辑通信。传输层协议能提供的服务被底层的网络层协议所限制。</p><p>部署：传输层协议在<strong>end systems</strong>中实现而非routers中，路由器只负责转发datagram。</p><p>行为：传输层协议将应用层message封装为传输层message，传输给网络层，网络层再封装成数据报datagram。也就是说每一层就都会将数据封装为能在该层传输、向下层传输的packet。</p><h3 id="11-transport-layer-protocols"><span class="mr-2">1.1 Transport layer protocols</span><a href="#11-transport-layer-protocols" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>between <strong>processes</strong> running on hosts</p><ol><li><p>UDP(User Datagram Protocol)-datagram/segment</p><li><p>TCP(Transmission Control Protocol)-segment</p></ol><p>两者都有/UDP仅有的services：</p><ol><li>transport-layer multiplexing and demultiplexing 传输层的多路复用与解复用，将host-host delivery扩展到process-process delivery<li>integrity/error checking</ol><p>TCP独有：</p><ol><li>reliable data transfer<li>congestion control</ol><h3 id="12-network-layer-protocols"><span class="mr-2">1.2 Network Layer protocols</span><a href="#12-network-layer-protocols" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>between <strong>hosts(IP addresses)</strong></p><p>IP(Internet Protocol)-datagram</p><p>services:</p><ol><li><p>best-effort delivery service</p><li><p>no guarantees, unreliable service</p></ol><h2 id="2-multiplexing--demultiplexing"><span class="mr-2">2. Multiplexing &amp; Demultiplexing</span><a href="#2-multiplexing--demultiplexing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Conclusion：在多主机、多应用、多进程、多socket上，不同应用间的通信是通过segment在socket中传输实现的，多路复用/解复用就用于定位一个segment的目的socket与源socket是什么，解复用是发送至socket，多路复用是从socket接收并发至网络层，这通过两者实现：1）唯一标识符socket，2）segment中指定源与目的socket <strong>port number</strong>。UDP socket只关注目的地，而TCP socket由于面向连接，会建立源-目的地的一对一连接。</p><p>已知：多主机，多应用，一个应用对应多进程，一个进程对应多socket（多线程），segment要通过socket传输。</p><p>需求：问题在于如何找到正确的socket，多路复用/解复用服务能解决这个问题。所有计算机网络都需要多路复用/解复用服务。</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302141743186.png" alt="image-20230214174355071" style="zoom:50%;" data-proofer-ignore></p><h3 id="21-definition"><span class="mr-2">2.1 definition</span><a href="#21-definition" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li><p>demultiplexing，解复用，就是将transport-layer segment中的data传送到正确的socket中</p><li><p>multiplexing，多路复用，将从不同socket接收到的data chunks封装成segments，添加头信息（用于解复用），发送至network layer</p></ol><p>要实现这项技术这需要：</p><ol><li><p>unique identifiers for sockets 唯一标识符socket</p><li><p>segment中含有字段指定destination socket，而这包括source port number &amp; destination port number（每个端口号都是16-bit number，传输层一般指定1024-65535 ，0-1023是著名端口号，一般为一些广泛使用的application保留，如HTTP-80）</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302141750994.png" alt="image-20230214175055942" style="zoom:50%;" data-proofer-ignore></p></ol><p>一般来说，应用的client side会让传输层自动生成socket端口号，而server side则指定一个特定端口号</p><h3 id="22-multiplexing--demultiplexing-in-udp"><span class="mr-2">2.2 Multiplexing &amp; Demultiplexing in UDP</span><a href="#22-multiplexing--demultiplexing-in-udp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>$return\ address = source\ port\ number + source\ IP\ address$</p><p>$UDP\ socket= (destination\ IP\ address,\ destination\ port\ number)$</p><p>UDP只关注目的地，一个UDP socket能接收source不同、发送destination不同的信息。</p><h3 id="23-multiplexing--demultiplexing-in-tcp"><span class="mr-2">2.3 Multiplexing &amp; Demultiplexing in TCP</span><a href="#23-multiplexing--demultiplexing-in-tcp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>$TCP\ socket=(source\ IP\ address,\ source\ port\ number,\ destination\ IP\ address,<br /> destination\ port\ number)$</p><p>TCP关注source &amp; destination，完全双向一对一连接。</p><p><strong>原理：</strong></p><ol><li>TCP server具有一个welcoming socket，用于等待连接请求<li>TCP client创建一个socket，通过其发送连接请求segment，会在其中指定其该四元组<li>TCP server收到连接请求后，根据该请求segment中的四元组创建一个新的socket</ol><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302151702629.png" alt="image-20230215170204494" style="zoom:67%;" data-proofer-ignore></p><h3 id="24-security"><span class="mr-2">2.4 Security</span><a href="#24-security" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>攻击者可以监听/攻击一些知名应用的默认端口，造成其缓冲区溢出，可能可以在该主机上执行任何代码。因此有必要查询本机中监听端口的进程，可以用nmap。</p><h2 id="3-udpuser-datagram-protocol"><span class="mr-2">3. UDP(User Datagram Protocol)</span><a href="#3-udpuser-datagram-protocol" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Conclusion：UDP header中有源端口号、目的端口号（用于多路复用/解复用），length与checksum（提供data integrity服务，将16bit data相加后取反，进位时最低位+1，接收时data+checksum全为1则说明无误）。使用UDP的应用有：DNS（实时性、无需连接、减小内存占用、UDP header字节更少更轻量），SNMP，NFS。</p><p>UDP从应用程序进程中获取消息，为多路复用/解复用服务附加源端口号和目的端口号字段，添加另外两个小字段，并将结果段传递给网络层。</p><p>why connectionless: no handshaking before communication</p><h3 id="31-udp-segment-structure"><span class="mr-2">3.1 UDP segment structure</span><a href="#31-udp-segment-structure" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302171400793.png" alt="image-20230217140050722" style="zoom:50%;" data-proofer-ignore></p><p>UDP header有8 bytes，指定了源和目的的端口号用于multiplexing &amp; demultiplexing，而源IP和目的IP是由network layer封装的，在IP datagram header，作为伪UDP segment header。</p><h4 id="311-checksum"><span class="mr-2">3.1.1 checksum</span><a href="#311-checksum" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>UDP提供error detection功能，考虑到既不能保证链路的可靠性（link-layer protocol不提供reliability）也不能保证内存中的错误检测，如果端端数据传输服务要提供错误检测，UDP必须在传输层提供端到端错误检测，但是UDP只检查错误，废除segment或warning，不会correct。类似based on UDP的应用可以在应用层提供可靠数据传输，主要是衡量在更低或更高级别实现该功能的成本与必要性。UDP header中用checksum检测是否出错：</p><ol><li>发送方将segment中所有的16-bit字相加，循环进位（进位时最低位+1），再求反码（对无符号二进制数字来说，先反后加和先加后反是一样的），作为header中checksum字段的值，发送segment<li>接收时计算data中所有的16-bit字与header中checksum之和，若全为1则正确，若有一个0则说明该packet出错</ol><h3 id="32-applications-running-on-udp"><span class="mr-2">3.2 Applications running on UDP</span><a href="#32-applications-running-on-udp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>DNS<ol><li>Finer application-level control over what data is sent, and when 应用程序级控制什么时间发送什么数据（TCP有拥堵控制，会造成延迟，有些应用能够容忍data loss）<li>No connection establishment 无需连接，三次握手很耗时；这就是为什么DNS用UDP。HTTP用TCP（需要可靠数据传输），针对使用后者造成的延迟，chrome使用QUIC protocol(Quick UDP Internet Connection，在UDP作为传输层协议的基础上，在<strong>应用层协议</strong>上实现了可靠数据传输)<li>No connection state 记录连接状态需要缓冲区与拥堵控制参数，会占用内存<li>Small packet header overhead，TCP segment header-20 bytes，UDP segment header-8 bytes</ol><li>SNMP(network management)<li>NFS(remote file server)</ol><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302151732401.png" alt="image-20230215173234288" style="zoom:50%;" data-proofer-ignore></p><h2 id="4-reliable-data-transfer"><span class="mr-2">4. Reliable Data Transfer</span><a href="#4-reliable-data-transfer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302161356809.png" alt="image-20230216135656649" style="zoom: 50%;" data-proofer-ignore></p><p>本章只讨论unidirectional data transfer(only sender-&gt;receiver)的RDT protocols。</p><p>bidirectional(full-duplex)</p><div class="table-wrapper"><table><tbody><tr><td>参考：[可靠数据传输原理<td>YieldNull](https://yieldnull.com/blog/943b65e3a64843303b8f15e1acbf79a77ace947f/#21-rdt-21-acknak)</table></div><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302171348150.png" alt="image-20230217134815103" style="zoom:67%;" data-proofer-ignore></p><p><em>Conclusion：</em></p><ol><li>rdt1.0：假设信道完全可靠，接收方无需任何feedback。<li>rdt2.x：假设信道存在bit error，即packet可能受损但不丢包。<ol><li>rdt2.0：接收方采用ACK, NAK, ARQ，接收方确认收到传送ACK，出错传送NAK，发送方收到NAK则重传。<li>rdt2.1：假设ACK/NAK packet也可能受损，发送方只要收到受损的feedback packet就重传，为排除冗余packet，为数据packet添加单bit序号字段1/0，接收方使用ACK, NAK 1/0。<li>rdt2.2：接收方移除NAK，采用ACK 1/0。</ol><li>rdt3.0：假设信道存在bit error且lossy，即packet可能受损或可能丢包，发送方发送每个packet时启动<strong>定时器</strong>，超时则重传，接收方使用ACK 1/0。<li>pipelined：rdt协议的缺陷是由于其核心为<strong>停等协议</strong>，每次传输都至少要等待一个RTT，因此采用流水线设计，不需要等待前序packet被确认收到。<ol><li>Go Back N：序号范围扩大，双方都需要维持缓冲区。发送方维护<strong>一个全局计时器</strong>和一个窗口(base,nextseqnum)，base为最小未确认packet的序号，每次更新base时重启计时器，<strong>超时重传当前窗口所有未确认的分组</strong>。接收方采用<strong>累计确认</strong>ACK k，不符合当前需求序号k的packet一律丢弃，即接收方保证正确、正序确认packet。<li>Selective Repeat：双方都维持缓冲区和窗口，且由于feedback的延迟或丢包，窗口不同步。发送方<strong>为每个分组维持一个定时器</strong>，超时重传。接收方只要确认收到当前窗口和上一窗口范围内的分组，就发送ACK k（即使冗余），防止由于ACK丢失，发送方一直重传。</ol></ol><h3 id="41-rdt10"><span class="mr-2">4.1 rdt1.0</span><a href="#41-rdt10" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>完全可靠信道，假定双方发送/接收速率一致，理想状态，也最简单，一发一收就行，接收方无需任何反馈信息。</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302161443545.png" alt="image-20230216144302461" style="zoom: 80%;" data-proofer-ignore></p><h3 id="42-rdt20"><span class="mr-2">4.2 rdt2.0</span><a href="#42-rdt20" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>比特差错信道，收到的packet可能受损。</p><p>需要以下功能：</p><ol><li><p>ACK(postive acknowledg)</p><li><p>NAK(negative acknowledge)</p><li><p>ARQ(Automatic Repeat reQuest)，自动重传请求，存在比特差错则请求重传</p></ol><p>实现ARQ还需要三种协议功能：检测、反馈、重传</p><ol><li>error detection, <strong>发送方</strong>在packet中添加额外的checksum bit字段用于<strong>检测</strong><li>receiver feedback，<strong>接收方反馈</strong>是否正确接收<li>retransmission，<strong>发送方重传</strong></ol><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302161504634.png" alt="image-20230216150459520" data-proofer-ignore></p><p><del>但ACK/NAK packet的命也是命</del></p><p>但ACK/NAK packet也可能受损，解决方法是：</p><ol><li>收到受损的feedback packet就直接重传，这样会导致冗余分组（duplicate packet），即接收方不确定该packet是新packet还是重传<li>针对这个问题，发送方为每个packet添加序号字段，接收方检测其序号即可确定是否重传（对于停等协议，由于发送方必须确保当前特定packet送达才能继续传送下一个，时序性是一定的，只要确定序号字段是否改变即可，可以用1/0）</ol><h4 id="422-rdt21"><span class="mr-2">4.2.2 rdt2.1</span><a href="#422-rdt21" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>针对ACK/NAK packet可能受损的问题进行改进，发送方为每个packet添加单bit序号1/0，只要收到受损的feedback packet就重传，接收方通过检测序号是否匹配状态来判断是否冗余分组。</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302161532286.png" alt="image-20230216153226177" style="zoom: 67%;" data-proofer-ignore></p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302161537978.png" alt="image-20230216153704852" style="zoom: 67%;" data-proofer-ignore></p><h4 id="422-rtd22"><span class="mr-2">4.2.2 rtd2.2</span><a href="#422-rtd22" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>移除了NAK，只使用ACK 1/0。</p><p>发送方：收到的ACK序号与状态不匹配则重传，反之switch</p><p>接收方：若packet受损则发送与状态相反的ACK，反之发送与packet序号一致的ACK</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302161540921.png" alt="image-20230216154020788" style="zoom: 67%;" data-proofer-ignore></p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302161547339.png" alt="image-20230216154717216" style="zoom:67%;" data-proofer-ignore></p><h3 id="43-rdt30"><span class="mr-2">4.3 rdt3.0</span><a href="#43-rdt30" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>比特差错、丢包信道，现在涉及到<strong>受损、丢包、超时和乱序</strong>的情况，相比rdt2.2，<strong>发送方每次发送packet都会启动定时器</strong>。</p><ol><li>检测丢包（设置定时器，不论能否确定丢包都重发）<li>丢包后如何弥补（ARQ，重传机制；rdt2.2，处理冗余packet）</ol><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302161637131.png" alt="image-20230216163757002" style="zoom:67%;" data-proofer-ignore></p><p>接收方与rdt2.2是一致的，只关心收到的packet，错误则传送与状态相反标号的ACK，其余情况传送与packet相同标号的ACK，只有与当前所在状态标号相同的时候向上层传输数据。</p><p>发送方每次发送packet都启动定时器，每隔一个cycle就重传，直到接收到正确的ACK，关闭定时器，切换到下一状态，等待上层再次调用，该过程中忽略所有可能延迟到达的receiver feedback。</p><p>由于01序号交替，也被称为alter-nating-bit protocol比特交替协议</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302202337494.png" alt="image-20230220233724303" style="zoom:67%;" data-proofer-ignore></p><h3 id="44-pipelined-reliable-data-transfer-protocols"><span class="mr-2">4.4 Pipelined Reliable Data Transfer Protocols</span><a href="#44-pipelined-reliable-data-transfer-protocols" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>rdt协议的缺陷是由于其核心为停等协议，每次传输都至少要等待一个RTT，效率低下，因此采用pipeline技术，发送端能任意发送多个分组到信道中，毋须按照严格时序。</p><p><strong>shortage：</strong></p><ol><li>rdt3.0的比特交替分组编号方式（0-1）失效，需要增加编号范围<li>分组可能会失序到达，双方都需要建立缓冲区</ol><p><strong>分配序号：</strong></p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302161718891.png" alt="image-20230216171847792" data-proofer-ignore></p><p>参数：</p><ol><li>N：这里的N不是固定的，$N=nextseqnum-base+1$，但有上限<li><p>base：最小未被确认packet的序号</p><li>nextseqnum：下一个等待被调用发送的packet序号</ol><p><strong>序号范围：</strong>一般序号会承载在packet header的一个固定字段中，序号范围由<strong>字段大小<code class="language-plaintext highlighter-rouge">k</code></strong>进行确定，为[0,2^k^-1]。当序号用完之后，进行取模运算，从头开始编号。由于序号是取模分配的，如果窗口长度N和序号范围太接近，在一个窗口中存在两个相同序号，产生冲突。对选择重传协议而言，<strong>窗口长度必须小于或等于序号空间大小的一半</strong>。</p><p>两种方式处理数据<strong>丢失、损坏、失序、超时</strong>：</p><ol><li>Go Back N，退回N步<li>Selective Repeat，选择</ol><h4 id="441-go-back-n"><span class="mr-2">4.4.1 Go Back N</span><a href="#441-go-back-n" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>初始情况下，<code class="language-plaintext highlighter-rouge">base=1</code>, <code class="language-plaintext highlighter-rouge">nextseqnum=1</code>。发送方要响应三个事件：</p><ol><li>上层调用<li>receiver feedback<ol><li>error，继续等<li>ACK k，base=K+1，移动窗口<ol><li>若所有分组已确认（也没有要发送的了），关闭计时器等待上层再次调用<li>若还有分组未确认，重启定时器</ol></ol><li>time out，GBN协议重传所有已发送但未被确认（窗口内）的分组</ol><p>发送方：</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302161720941.png" alt="image-20230216172002767" style="zoom:67%;" data-proofer-ignore></p><p>发送方只有一个全局timer，每次所有已发送packet已确认时停止，每次超时、base未确认，都会重启定时器。</p><p>接收方：</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302161730027.png" alt="image-20230216173013901" style="zoom:67%;" data-proofer-ignore></p><p>重传之后累计确认的问题：由于接收方按序接收，假设packet k超时，从它开始后面的数据都会被丢弃/缓存，无法确认，因此累计到的expectedseqnum也不会变，依然还是k-1，直到确认packet k开始。</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302161731118.png" alt="img" data-proofer-ignore></p><p>shortage：</p><ol><li>一旦某个分组超时/丢失，就引起大量分组重传，成本较大<li>接收方的累计确认机制会丢弃乱序的分组，造成重传</ol><h4 id="442-selective-repeat"><span class="mr-2">4.4.2 Selective Repeat</span><a href="#442-selective-repeat" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>选择重传</strong>是对退回N步协议的改进，即发送方只会重传那些它怀疑在接收方出错（丢失或受损）的分组，而接收方将失序但正确的分组缓存起来，从而避免不必要的重传。相比Go Back N，其为每个packet维护一个定时器，超时未确认则重传。</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302170123522.png" alt="image-20230217012353429" style="zoom:67%;" data-proofer-ignore></p><p>由于ACK也有丢包的可能性，每次接收方收到上个窗口[rcv_base-N,rcv_base)的packet，都返回ACK，防止发送方未收到ACK一直重传。</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302170206217.png" alt="image-20230217020600115" style="zoom:67%;" data-proofer-ignore></p><h2 id="5-tcptransmission-control-protocol"><span class="mr-2">5. TCP(Transmission Control Protocol)</span><a href="#5-tcptransmission-control-protocol" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Conclusion：TCP的特征为面向连接（体现在3次握手）、全双工、点对点（多重广播）、双向传输。</p><p>TCP的连接管理：</p><ol><li>3次握手：client开辟连接，发送SYN segment（SYN=1)，server发送SYNACK segment（单独ACK不包含任何数据，不是捎带确认，该确认segment中会给予该SYN segment一个cookie，此时不开辟连接，防止SYN flood attack），client发送ACK segment，可能包含请求数据，收到后server开辟连接。<li>关闭连接：client发送FIN segment（FIN=1）请求关闭，server发送ACK确认后一段时间再发送FIN segment，client确认后，两端真正关闭连接。</ol><p>TCP提供RDT、流控制、拥塞控制服务。</p><ol><li>RDT：发送方维持一个定时器，超时重传，并累计确认，收到冗余ACK就快速重传，无需等到超时。<li>流控制：在header中维持一个receive window（用最后读取、最后接收、最后发送、最后确认与buffer size来表示）。<li>拥塞控制：<ol><li>通过cwnd控制速度；<li>丢包（超时/冗余ACK x3）视为拥堵，收到一个ACK则增大cwnd，pushy strategy；<li>拥塞控制算法：初始cwnd=MSS，慢启动（cwnd+=MSS，指数增长）、拥塞避免（cwnd+=MSS*MSS/cwnd，线性增长）、快速恢复（cwnd+=MSS，指数增长），只要丢包（timeout/duplicate ACK）ssthresh=cwnd/2且重传，超时则重启慢启动，冗余ACK则cwnd=ssthresh+3MSS，进入快速恢复，直到首次收到新的ACK，视为拥塞结束，进入拥塞避免。</ol></ol><h3 id="51-definition"><span class="mr-2">5.1 Definition</span><a href="#51-definition" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="features"><span class="mr-2">Features</span><a href="#features" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li>connection-oriented: 3-way handshake<li>full-duplex service<ol><li>point-to-point, multicasting<li>bidirectional</ol></ol><h4 id="mss-mtu-tcp-segment-size"><span class="mr-2">MSS, MTU, TCP segment size</span><a href="#mss-mtu-tcp-segment-size" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>MSS（Maximum Segment Size）是指TCP协议中一个数据段（segment）能够承载的最大数据量（不包括TCP header，只是应用层所需data field），它是TCP连接双方在握手过程中协商得出的结果。</p><p>MTU（Maximum Transmission Unit）是指数据链路层协议中一个数据帧（frame）能够承载的最大数据量。</p><p>TCP segment size指的是一个TCP数据段的大小，它包括TCP首部和数据部分。发送方根据MTU的大小来调整MSS的大小，以确保发送的TCP数据段可以被正确地传输和接收。</p><h4 id="tcp-segment-structure"><span class="mr-2">TCP segment structure</span><a href="#tcp-segment-structure" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303301519239.png" alt="image-20230217161031376" style="zoom: 50%;" data-proofer-ignore></p><p>TCP将数据看作无组织但有序的字节流，为每个字节编号与累计确认来实现有序确认。</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303301519633.png" alt="image-20230217162607207" style="zoom:50%;" data-proofer-ignore></p><p>Sequence number: 为file data的<strong>每个字节</strong>编号，[0,MSS]为segment 1，[MSS,2MSS]为segment 2，以此类推。但一般会随机初始化序号，否则容易造成冲突。</p><p>acknowledgement number：TCP可能收到乱序的segment，此时会将其缓存等待重排。TCP接收方会在acknowlegment number field填入其需求的最小的字节编号，比如已收到[0,55],[100,155]，其发送给发送方的segment中acknowlegment number为56。TCP采用累计确认机制（cumulative acknowledgements），每次只确认最小的缺失字节编号。</p><p>捎带确认：<strong>接收端</strong>发送数据时顺带地返回一个确认（ACK）信息，而不需要独立地发送一个ACK消息。发送端只能独立发送ACK消息。减少网络上的通信次数，提高网络效率。</p><p>以下情况接收端必须独立发送ACK：</p><ol><li>接收端接收到SYN segment时，需要独立发送SYNACK作为第二次握手的响应。<li>接收端接收到一个受损segment时。捎带确认只能确认已经正确接收的数据。</ol><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302172126972.png" alt="image-20230217212603886" style="zoom: 67%;" data-proofer-ignore></p><p>Telnet：用于远程登陆的应用层协议</p><h3 id="52-rtt-estimation-and-timeout"><span class="mr-2">5.2 RTT Estimation and Timeout</span><a href="#52-rtt-estimation-and-timeout" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>$EstimatedRTT=(1-\alpha) \cdot EstimatedRTT +\alpha \cdot SampleRTT $</p><p>TCP通过一定策略计算SampleRTT（不会采样每个segment），并计算其指数加权移动平均(EWMA)，估计出EstimatedRTT。</p><div class="table-wrapper"><table><tbody><tr><td>$DevRTT=(1-\beta)\cdot DevRTT+\beta \cdot<td>SampleRTT-EstimatedRTT<td>$</table></div><p>DevRTT是预测值与测量值差值的EWMA。</p><p>$TimeoutInterval=EstimatedRTT+4\cdot DevRTT$</p><p>出现超时后，TimeoutInterval应当加倍，以免即将被确认的后继报文段过早出现超时。但只要收到报文段并更新EstimatedRTT，就再次计算TimeoutInterval。</p><h3 id="53-rdt-service-in-tcp"><span class="mr-2">5.3 RDT service in TCP</span><a href="#53-rdt-service-in-tcp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>assumption：发送方不受TCP流控制、拥塞控制的限制；数据长度小于MSS（不需要切割），且单向数据传送。</p><p>TCP在发送方部署一个single timer，发送方响应以下事件：</p><ol><li>call from above，从上层接受数据，若定时器未运行，启动定时器；<li>Timeout，重传最小序号的未应答segment，启动定时器；<li>receiver feedback，收到ACK k，TCP采用累计确认，这可以说明k以前的字节都已经收到，故更新base。若当前仍然存在未应答segment，启动定时器。</ol><h4 id="快速重传"><span class="mr-2">快速重传</span><a href="#快速重传" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>duplicate ACK：假设接收方当前需求为segment y，接收方只要收到的segment k(k&gt;y)，就发送冗余ACK y，发送方只要收到3次ACK y，就快速重传y。此外，由于TCP采用累计确认，只要收到ACK k(k&gt;y)，就会在超时前重启计时器，无需重传segment y。</p><p>TCP不是GBN协议（不会重传一整个窗口），也不完全是SR协议（TCP可以有选择地确认失序报文段），可以被分类为其混合体。</p><h3 id="54-flow-control"><span class="mr-2">5.4 FLow Control</span><a href="#54-flow-control" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>用receive window来实现Flow Control。</p><ol><li>receiver：<ol><li>LastByteRead:应用从缓存中读取的最后一个字节编号<li>LastByteRcvd: 最后一个放入缓存的字节编号<li>RcvBuffer: total buffer size<li>rwnd: receive window=RcvBuffer-[LastByteRcvd-LastByteRead]</ol><li>sender：<ol><li>LastByteSent<li>LastByteAcked</ol></ol><p>$LastByteSent-LastByteAcked≤ rwnd$</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303301519070.png" alt="image-20230218154756388" style="zoom:50%;" data-proofer-ignore></p><p>当rwnd为0时，sender会一直继续发送单字节数据segment，这些segment会被receiver确认，直到确认segment中包含一个非0的rwnd。</p><h3 id="55-connection-management"><span class="mr-2">5.5 Connection Management</span><a href="#55-connection-management" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="3-way-handshake"><span class="mr-2">3-way handshake</span><a href="#3-way-handshake" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li>client TCP发送SYN segment，SYN=1，序号client_isn随机初始化<li>server为该连接分配TCP缓存和变量，向client TCP发送SYNACK segment，SYN=1，ACK=client_isn+1，包含初始化的server_isn<li>client为该连接分配缓存和变量，向server发送segment，SYN=0，ACK=server_isn+1，该segment可以负载data</ol><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303301519098.png" alt="image-20230218161543559" style="zoom:67%;" data-proofer-ignore></p><h4 id="close"><span class="mr-2">close</span><a href="#close" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li>client发送close request，segment中FIN=1<li>server发送ACK，再发送其终止segment，FIN=1<li>client发送ACK，client TCP等待30s后终止，释放资源<li>server收到ACK，server TCP终止，释放资源</ol><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202303301519988.png" alt="image-20230218161833457" style="zoom:67%;" data-proofer-ignore></p><h4 id="syn-flood-attack---classic-dos-attack"><span class="mr-2">SYN flood attack - classic Dos attack</span><a href="#syn-flood-attack---classic-dos-attack" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>向服务器发送多个SYN segment，server会在第二次握手为其开辟空间，导致服务器连接资源殆尽</p><p>SYN cookie：收到连接请求时生成一个初始TCP序列号，与SYN segment的源地址有关，作为cookie，不开辟空间，发送含有该序列号的SYNACK segment；当client返回第三次握手的ACK segment，验证该ACK segment序号与SYNACK segment中的cookie值匹配，此时server才生成连接。</p><h3 id="56-congestion-control"><span class="mr-2">5.6 Congestion Control</span><a href="#56-congestion-control" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>根据【网络层是否为运输层拥塞控制提供了显式帮助】来分类：</p><ol><li>end-to-end，无关网络层，TCP采用这种方法<li>网络辅助的拥塞控制，routers向发送方提供显式反馈信息。<ol><li>routers-sender：choke packet<li>receiver-sender：路由器标记packet中的某个field，收到flagged packet后，receiver通知sender，这种通知至少要经过一个RTT</ol></ol><h4 id="tcp-congestion-control"><span class="mr-2">TCP Congestion Control</span><a href="#tcp-congestion-control" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>TCP拥塞控制通过三个方面实现：</p><ol><li>TCP发送方能够限制发送流量的速率<li>TCP发送方能够感知拥塞<li>TCP发送方感知到拥塞时，如何应对</ol><h5 id="限制流量速率"><span class="mr-2">限制流量速率</span><a href="#限制流量速率" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>变量：</p><ol><li>LastByteSent<li>LastByteAcked<li>cwnd，congestion window</ol><p>$LastByteSend-LastAcked≤min{cwnd,rwnd}$</p><p>v=cwnd/RTT，通过调整cwnd的值，可以调整连接发送数据的速率</p><h5 id="感知拥塞"><span class="mr-2">感知拥塞</span><a href="#感知拥塞" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>丢包：timeout/3 duplicate ACK(4 ACK in total)，视作拥堵，减小cwnd</p><p>ACK segment：TCP是self-clocking的，使用确认/计时来增大cwnd</p><p>带宽检测：只要收到ACK，一直增加cwnd，直到出现丢包，减小该速率，然后再次开始探测（增大cwnd），总之就是不停试探边界</p><h5 id="拥塞控制算法"><span class="mr-2">拥塞控制算法</span><a href="#拥塞控制算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><ol><li>慢启动slow-start（强制）<ol><li>initial：cwnd≤MSS，v=MSS/RTT<li>收到一个首次确认的ACK就翻倍，MSS*2^n^<li>若出现拥塞，更新慢启动阈值ssthresh（slow-start thresh）=cwnd/2<ol><li>超时，cwnd重置为1MSS，<strong>重新开始慢启动</strong><li>3 冗余ACK，TCP快速重传，cwnd=ssthresh+3MSS，进入快速恢复</ol><li>当cwnd≥ssthresh，结束慢启动，进入拥塞避免</ol><li>拥塞避免（强制）<ol><li>每个RTT，cwnd+=MSS，线性增加；例如，对每个到达的ACK，cwnd+=MSS*MSS/cwnd<li>拥塞，ssthresh=0.5 cwnd<ol><li>timeout，cwnd=1MSS<li>三个冗余ACK，cwnd=ssthresh+3MSS，进入快速恢复</ol></ol><li>快速恢复（推荐）<ol><li>收到ACK，cwnd=ssthresh，切换拥塞避免<li>拥塞<ol><li>超时，ssthresh=cwnd/2，cwnd=1 MSS，重启慢启动<li>冗余ACK，cwnd+=MSS，快速恢复的主体</ol></ol></ol><p>AIMD(Additive-Increase, Multiplicative-Decrease, AIMD)，加性增、乘性减：TCP线性增加其cwnd，直到出现3个冗余ACK，cwnd减半，再开始线性增长，不断探测可用带宽</p><p><img data-src="https://raw.githubusercontent.com/WitchPuff/typora_images/main/img/202302181800410.png" alt="image-20230218180023238" style="zoom:67%;" data-proofer-ignore></p><p>高度理想化的TCP稳态动态性模型：</p><p>$一条连接的平均吞吐量=\frac{0.75W}{RTT}$</p><p>W:当前cwnd</p><p>经高带宽路径的TCP：</p><p>$一条连接的平均吞吐量=\frac{1.22MSS}{RTT \sqrt{L}}$</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/courses/'>Courses</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/computer-network/" class="post-tag no-text-decoration" >Computer Network</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Computer+Network%3A+Transport+Layer%282%29+-+CyberWitch&url=https%3A%2F%2Fwitchpuff.github.io%2Fposts%2Ftransport%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Computer+Network%3A+Transport+Layer%282%29+-+CyberWitch&u=https%3A%2F%2Fwitchpuff.github.io%2Fposts%2Ftransport%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fwitchpuff.github.io%2Fposts%2Ftransport%2F&text=Computer+Network%3A+Transport+Layer%282%29+-+CyberWitch" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="http://service.weibo.com/share/share.php?title=Computer+Network%3A+Transport+Layer%282%29+-+CyberWitch&url=https%3A%2F%2Fwitchpuff.github.io%2Fposts%2Ftransport%2F" data-toggle="tooltip" data-placement="top" title="Weibo" target="_blank" rel="noopener" aria-label="Weibo"> <i class="fa-fw fab fa-weibo"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/transport/">Computer Network: Transport Layer(2)</a><li><a href="/posts/classification/">Machine Learning: Classification</a><li><a href="/posts/sqlite3/">ModuleNotFoundError: No module named '_sqlite3'解决方法</a><li><a href="/posts/clustering/">Machine Learning: Clustering</a><li><a href="/posts/astar/">Solving 15-Puzzle with A* and IDA*</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/computer-network/">Computer Network</a> <a class="post-tag" href="/tags/machine-learning/">Machine Learning</a> <a class="post-tag" href="/tags/bart/">BART</a> <a class="post-tag" href="/tags/music-generation/">Music Generation</a> <a class="post-tag" href="/tags/searching/">Searching</a> <a class="post-tag" href="/tags/a/">A*</a> <a class="post-tag" href="/tags/clustering/">Clustering</a> <a class="post-tag" href="/tags/cnn/">CNN</a> <a class="post-tag" href="/tags/computer-architecture/">Computer Architecture</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Application/"><div class="card-body"> <em class="small" data-ts="1675992990" data-df="ll" > Feb 10, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Computer Network: Application Layer</h3><div class="text-muted small"><p> Overview The * Layer Internet Model Applications 1. Principles of network applications 1.1 Network application architectures ...</p></div></div></a></div><div class="card"> <a href="/posts/NetworkLayerControlPlane/"><div class="card-body"> <em class="small" data-ts="1675992990" data-df="ll" > Feb 10, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Computer Network: Control Plane of Network Layer</h3><div class="text-muted small"><p> Network Layer: Control Plane RIP, Router Information Protocol OSPF(Open Shortest Path First，开放式最短路径优先) 层次化路由 Network Layer: Control Plane 路由算法 集中式：全局网络知识计算，需...</p></div></div></a></div><div class="card"> <a href="/posts/NetworkLayerDataPlane/"><div class="card-body"> <em class="small" data-ts="1675992990" data-df="ll" > Feb 10, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Computer Network: Data Plane of Network Layer</h3><div class="text-muted small"><p> Network Layer: Data Plane 1. Network Layer Services 2. Router 2.1 input port processing 2.2 Switching fabric 2.2.1 switching...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/NetworkLayerDataPlane/" class="btn btn-outline-primary" prompt="Older"><p>Computer Network: Data Plane of Network Layer</p></a> <a href="/posts/bart/" class="btn btn-outline-primary" prompt="Newer"><p>Paper Summary of BART</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "WitchPuff/WitchPuff.github.io", "data-repo-id": "R_kgDOHwS97Q", "data-category": "Announcements", "data-category-id": "DIC_kwDOHwS97c4CQnTG", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="">WitchPuff</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/computer-network/">Computer Network</a> <a class="post-tag" href="/tags/machine-learning/">Machine Learning</a> <a class="post-tag" href="/tags/bart/">BART</a> <a class="post-tag" href="/tags/music-generation/">Music Generation</a> <a class="post-tag" href="/tags/searching/">Searching</a> <a class="post-tag" href="/tags/a/">A*</a> <a class="post-tag" href="/tags/clustering/">Clustering</a> <a class="post-tag" href="/tags/cnn/">CNN</a> <a class="post-tag" href="/tags/computer-architecture/">Computer Architecture</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
